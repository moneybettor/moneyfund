<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.9">
  <title>MoneyFund Airdrop</title>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/web3@1.6.0/dist/web3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0A0C1E, #1F2A44);
      color: #E5E7EB;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 24px;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" opacity="0.03"%3E%3Cdefs%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.7" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3C/defs%3E%3Crect width="100%" height="100%" filter="url(%23noise)"/%3E%3C/svg%3E');
      z-index: -1;
    }

    h1 {
      color: #FFFFFF;
      margin-bottom: 24px;
      font-size: 2.4rem;
      font-weight: 700;
      max-width: 600px;
      width: 100%;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .wallet-container {
      display: flex;
      gap: 16px;
      max-width: 600px;
      width: 100%;
      margin-bottom: 16px;
    }

    .wallet-container select,
    .wallet-container button {
      flex: 1;
      min-width: 0;
    }

    label {
      display: block;
      margin: 16px 0 8px;
      font-weight: 500;
      color: #D1D5DB;
      max-width: 600px;
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
    }

    .label-with-help {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      max-width: 600px;
      width: 100%;
    }

    .help-icon {
      cursor: pointer;
      font-size: 0.75rem;
      width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 50%;
      background: #4B5563;
      color: #E5E7EB;
      transition: background 0.3s, transform 0.2s;
    }

    .help-icon:hover {
      background: #374151;
      transform: scale(1.1);
    }

    .help-note {
      display: none;
      font-size: 0.8rem;
      color: #D1D5DB;
      background: rgba(17, 24, 39, 0.9);
      padding: 10px;
      border-radius: 8px;
      margin-top: 4px;
      border: 1px solid rgba(99, 102, 241, 0.2);
      max-width: 600px;
      width: 100%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .help-note.active {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    select, input, textarea {
      width: 100%;
      max-width: 600px;
      padding: 12px;
      margin-bottom: 16px;
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      background: rgba(17, 24, 39, 0.9);
      color: #E5E7EB;
      font-size: 1rem;
      text-align: center;
      transition: border 0.3s, box-shadow 0.3s, background 0.3s;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.15);
    }

    select:hover, input:hover, textarea:hover {
      background: rgba(17, 24, 39, 0.95);
      border-color: rgba(99, 102, 241, 0.4);
      box-shadow: 0 0 8px rgba(99, 102, 241, 0.3);
    }

    select:focus, input:focus, textarea:focus {
      border-color: #6366F1;
      box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
      outline: none;
    }

    .amount-container {
      display: flex;
      gap: 16px;
      max-width: 600px;
      width: 100%;
      margin-bottom: 16px;
    }

    .amount-container > div {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .amount-container select,
    .amount-container input,
    .amount-container textarea {
      width: 100%;
      max-width: none;
      margin-bottom: 0;
    }

    .amount-container .label-with-help,
    .amount-container label {
      width: 100%;
      max-width: none;
    }

    .amount-container .help-note {
      width: 100%;
      max-width: none;
    }

    input::placeholder, textarea::placeholder {
      color: #9CA3AF;
      opacity: 0.8;
    }

    textarea {
      resize: vertical;
      height: 100px;
    }

    button {
      width: 100%;
      max-width: 600px;
      padding: 14px;
      margin: 12px 0;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: 600;
      background: linear-gradient(90deg, #4F46E5, #A855F7);
      color: #F9FAFB;
      transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
      position: relative;
      overflow: hidden;
    }

    button:hover {
      background: linear-gradient(90deg, #4338CA, #9333EA);
      transform: scale(1.03);
      box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
    }

    button:active::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      transform: scale(1);
      transition: transform 0.2s;
    }

    button:disabled {
      background: rgba(75, 85, 99, 0.6);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #connectMetaMaskBtn {
      font-size: 0.95rem;
      padding: 12px;
      background: #4B5EAA;
    }

    #connectMetaMaskBtn:hover {
      background: #3B4A8C;
      transform: scale(1.02);
    }

    #airdropButton {
      background: linear-gradient(90deg, #4F46E5, #A855F7);
    }

    #airdropButton:hover {
      background: linear-gradient(90deg, #4338CA, #9333EA);
    }

    .gas-settings {
      margin: 12px 0;
      font-size: 0.9rem;
      text-align: center;
      color: #D1D5DB;
      max-width: 600px;
      width: 100%;
    }

    #airdropLog {
      margin-top: 24px;
      max-height: 240px;
      overflow-y: auto;
      padding: 12px;
      background: rgba(31, 41, 55, 0.6);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 16px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      font-size: 0.9rem;
      text-align: left;
      max-width: 600px;
      width: 100%;
      z-index: 1;
      scrollbar-width: thin;
      scrollbar-color: #6366F1 rgba(31, 41, 55, 0.5);
    }

    #airdropLog::-webkit-scrollbar {
      width: 4px;
    }

    #airdropLog::-webkit-scrollbar-thumb {
      background: #6366F1;
      border-radius: 2px;
    }

    #airdropLog::-webkit-scrollbar-track {
      background: rgba(31, 41, 55, 0.5);
    }

    .airdrop-entry {
      background: rgba(17, 24, 39, 0.85);
      padding: 12px;
      margin: 8px 0;
      border-radius: 10px;
      color: #E5E7EB;
      border: 1px solid rgba(99, 102, 241, 0.15);
    }

    #connectionPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(31, 41, 55, 0.6);
      backdrop-filter: blur(16px);
      padding: 24px;
      border-radius: 16px;
      border: 1px solid rgba(99, 102, 241, 0.2);
      box-shadow: 0 10px 32px rgba(0, 0, 0, 0.25);
      display: none;
      z-index: 1001;
      color: #E5E7EB;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }

    #connectionPopup h3 {
      margin: 12px 0;
      font-size: 1.5rem;
      font-weight: 600;
      color: #FFFFFF;
    }

    #connectionPopup p {
      margin: 8px 0;
      font-size: 0.9rem;
      color: #D1D5DB;
    }

    #connectionPopup .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(99, 102, 241, 0.2);
      border-top: 4px solid #6366F1;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto;
    }

    #connectionPopup .checkmark {
      display: none;
      width: 48px;
      height: 48px;
      background: #10B981;
      border-radius: 50%;
      color: #FFFFFF;
      font-size: 28px;
      line-height: 48px;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #connectionPopup .close-btn {
      display: none;
      margin-top: 16px;
      padding: 12px;
      background: linear-gradient(90deg, #4F46E5, #A855F7);
      border: none;
      border-radius: 10px;
      color: #F9FAFB;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      width: 100%;
      transition: background 0.3s, transform 0.2s;
    }

    #connectionPopup .close-btn:hover {
      background: linear-gradient(90deg, #4338CA, #9333EA);
      transform: scale(1.02);
    }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 999;
      display: none;
    }
  </style>
</head>
<body>
    <h1>MoneyFund Airdrop</h1>
    <div class="wallet-container">
      <button id="connectMetaMaskBtn">Connect MetaMask</button>
      <select id="walletSelector" onchange="selectWallet(this.value)">
        <option value="">-- Select Wallet --</option>
      </select>
    </div>
    <div class="label-with-help">
      <label for="tokenAddress">Token Address:</label>
      <span class="help-icon" onclick="toggleHelpNote('token-address-help')">?</span>
    </div>
    <input type="text" id="tokenAddress" placeholder="e.g., 0x..." value="0x100DB67F41A2dF3c32cC7c0955694b98339B7311">
    <div id="token-address-help" class="help-note">Token address to airdrop.</div>
    <div class="label-with-help">
      <label for="recipients">Recipients (one per line):</label>
      <span class="help-icon" onclick="toggleHelpNote('recipients-help')">?</span>
    </div>
    <textarea id="recipients" placeholder="0xRecipientAddress"></textarea>
    <div id="recipients-help" class="help-note">Wallet addresses to receive the airdrop, one per line.</div>
    <div class="amount-container">
      <div>
        <div class="label-with-help">
          <label for="amountMode">Amount Mode:</label>
          <span class="help-icon" onclick="toggleHelpNote('amount-mode-help')">?</span>
        </div>
        <select id="amountMode" onchange="toggleAmountField()">
          <option value="uniform">Uniform</option>
          <option value="individual">Individual</option>
        </select>
        <div id="amount-mode-help" class="help-note">Choose uniform for the same amount to all recipients or individual for different amounts.</div>
      </div>
      <div>
        <div class="label-with-help">
          <label id="amountLabel" for="amountField">Set Uniform Amount for All:</label>
          <span class="help-icon" onclick="toggleHelpNote('amount-help')">?</span>
        </div>
        <input type="number" id="amountField" placeholder="e.g., 10" min="0" step="any" style="display: block;">
        <textarea id="amountFieldIndividual" placeholder="10" style="display: none;"></textarea>
        <div id="amount-help" class="help-note">Amount of tokens to airdrop, either uniform for all or one per line for individual mode.</div>
      </div>
    </div>
    <div class="gas-settings"></div>
    <button id="airdropButton" disabled>Send Airdrop</button>
    <div id="airdropLog"></div>

    <div id="connectionPopup">
      <div class="spinner" id="connectionSpinner"></div>
      <div class="checkmark" id="connectionCheckmark">âœ“</div>
      <h3 id="connectionStatusMessage">Processing...</h3>
      <p id="connectionAddress" style="display: none;"></p>
      <button class="close-btn" id="closeConnectionPopupBtn">Close</button>
    </div>
    <div id="overlay"></div>

    <script>
      function toggleHelpNote(noteId) {
        const note = document.getElementById(noteId);
        if (note.classList.contains('active')) {
          note.classList.remove('active');
        } else {
          document.querySelectorAll('.help-note.active').forEach(n => n.classList.remove('active'));
          note.classList.add('active');
        }
      }

      function loadEthers() {
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js";
          script.onload = () => resolve(window.ethers);
          script.onerror = () => {
            console.warn("Primary CDN failed, trying fallback...");
            const fallback = document.createElement("script");
            fallback.src = "https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js";
            fallback.onload = () => resolve(window.ethers);
            fallback.onerror = () => reject(new Error("Both CDNs failed to load ethers.js"));
            document.head.appendChild(fallback);
          };
          document.head.appendChild(script);
        });
      }

      function toggleAmountField() {
        const mode = document.getElementById("amountMode").value;
        const uniformField = document.getElementById("amountField");
        const individualField = document.getElementById("amountFieldIndividual");
        const amountLabel = document.getElementById("amountLabel");

        if (mode === "uniform") {
          uniformField.style.display = "block";
          individualField.style.display = "none";
          amountLabel.textContent = "Set Uniform Amount for All:";
        } else {
          uniformField.style.display = "none";
          individualField.style.display = "block";
          amountLabel.textContent = "Amounts (one per line):";
        }
      }

      (async () => {
        try {
          const ethers = await loadEthers();
          if (!ethers) throw new Error("ethers.js not loaded");

          const contractAddress = "0x6785cd86a65f3d8336fdc3b0e54c78215501dca2";
          const airdropAbi = [
            {
              "inputs": [],
              "stateMutability": "nonpayable",
              "type": "constructor"
            },
            {
              "inputs": [
                {
                  "internalType": "address",
                  "name": "owner",
                  "type": "address"
                }
              ],
              "name": "OwnableInvalidOwner",
              "type": "error"
            },
            {
              "inputs": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                }
              ],
              "name": "OwnableUnauthorizedAccount",
              "type": "error"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "internalType": "address",
                  "name": "previousOwner",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "internalType": "address",
                  "name": "newOwner",
                  "type": "address"
                }
              ],
              "name": "OwnershipTransferred",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "internalType": "address",
                  "name": "sender",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "internalType": "address",
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "TokensAirdropped",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "TokensRecovered",
              "type": "event"
            },
            {
              "inputs": [
                {
                  "internalType": "contract IERC20",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "address[]",
                  "name": "recipients",
                  "type": "address[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "amounts",
                  "type": "uint256[]"
                }
              ],
              "name": "airdropTokens",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "contract IERC20",
                  "name": "token",
                  "type": "address"
                }
              ],
              "name": "getContractBalance",
              "outputs": [
                {
                  "internalType": "uint256",
                  "name": "",
                  "type": "uint256"
                }
              ],
              "stateMutability": "view",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "owner",
              "outputs": [
                {
                  "internalType": "address",
                  "name": "",
                  "type": "address"
                }
              ],
              "stateMutability": "view",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "contract IERC20",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "recoverTokens",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "renounceOwnership",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "address",
                  "name": "newOwner",
                  "type": "address"
                }
              ],
              "name": "transferOwnership",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            }
          ];

          const erc20Abi = [
            {
              "constant": false,
              "inputs": [
                { name: "spender", type: "address" },
                { name: "amount", type: "uint256" }
              ],
              "name": "approve",
              "outputs": [{ type: "boolean" }],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                { name: "owner", type: "address" },
                { name: "spender", type: "address" }
              ],
              "name": "allowance",
              "outputs": [{ type: "uint256" }],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [{ name: "owner", type: "address" }],
              "name": "balanceOf",
              "outputs": [{ type: "uint256" }],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [],
              "name": "decimals",
              "outputs": [{ type: "uint8" }],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [],
              "name": "paused",
              "outputs": [{ type: "boolean" }],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            }
          ];

          let provider, signer, contract, tokenContract, web3, userAccount;
          let wallets = [];
          let selectedWallet = null;

          function showConnectionPopup(message) {
            const popup = document.getElementById("connectionPopup");
            const spinner = document.getElementById("connectionSpinner");
            const checkmark = document.getElementById("connectionCheckmark");
            const statusMessage = document.getElementById("connectionStatusMessage");
            const addressDisplay = document.getElementById("connectionAddress");
            const closeBtn = document.getElementById("closeConnectionPopupBtn");

            spinner.style.display = "block";
            checkmark.style.display = "none";
            closeBtn.style.display = "none";
            addressDisplay.style.display = "none";
            statusMessage.textContent = message;

            popup.style.display = "block";
            document.getElementById("overlay").style.display = "block";
          }

          function updateConnectionPopup({ message, address, success = false }) {
            const spinner = document.getElementById("connectionSpinner");
            const checkmark = document.getElementById("connectionCheckmark");
            const statusMessage = document.getElementById("connectionStatusMessage");
            const addressDisplay = document.getElementById("connectionAddress");
            const closeBtn = document.getElementById("closeConnectionPopupBtn");

            statusMessage.textContent = message;
            if (address) {
              addressDisplay.textContent = `Address: ${address.slice(0, 6)}...${address.slice(-4)}`;
              addressDisplay.style.display = "block";
            }
            if (success) {
              spinner.style.display = "none";
              checkmark.style.display = "block";
              closeBtn.style.display = "block";
            }
          }

          function hideConnectionPopup() {
            document.getElementById("connectionPopup").style.display = "none";
            document.getElementById("overlay").style.display = "none";
          }

          function updateSuggestedGas(recipientCount) {
            const baseGas = 60000;
            const perRecipientGas = 45000;
            const suggested = baseGas + (recipientCount * perRecipientGas);
            document.getElementById("suggestedGas") ? document.getElementById("suggestedGas").textContent = suggested : null;
            document.getElementById("gasLimit") ? document.getElementById("gasLimit").placeholder = suggested : null;
          }

          async function initializeWallets() {
            web3 = new Web3(web3 ? web3.currentProvider : "https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73");
            wallets = JSON.parse(localStorage.getItem('wallets') || '[]');

            if (window.ethereum && userAccount) {
              const metamaskWallet = { address: userAccount, type: 'MetaMask', isMetaMask: true };
              if (!wallets.some(w => w.address === metamaskWallet.address)) {
                wallets.push(metamaskWallet);
              }
            }

            wallets = wallets.map(wallet => {
              if (wallet.type === 'moneyfund' && wallet.privateKey) {
                return { ...wallet, isMetaMask: false };
              }
              return wallet;
            });

            localStorage.setItem('wallets', JSON.stringify(wallets));

            const walletSelector = document.getElementById('walletSelector');
            walletSelector.innerHTML = '<option value="">-- Select Wallet --</option>';
            wallets.forEach((wallet, index) => {
              const option = document.createElement('option');
              option.value = index;
              option.textContent = `${wallet.type}: ${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
              walletSelector.appendChild(option);
            });

            const selectedIndex = parseInt(localStorage.getItem('selectedWalletIndex')) || 0;
            if (wallets.length > 0 && selectedIndex >= 0 && selectedIndex < wallets.length) {
              selectedWallet = wallets[selectedIndex];
              walletSelector.value = selectedIndex;
              userAccount = selectedWallet.address;
              await selectWallet(selectedIndex);
              updateStatus();
            } else if (wallets.length > 0) {
              selectedWallet = wallets[0];
              localStorage.setItem('selectedWalletIndex', 0);
              walletSelector.value = 0;
              userAccount = selectedWallet.address;
              await selectWallet(0);
              updateStatus();
            }
          }

          async function selectWallet(index) {
            const idx = parseInt(index);
            if (idx >= 0 && idx < wallets.length) {
              selectedWallet = wallets[idx];
              localStorage.setItem('selectedWalletIndex', idx);
              userAccount = selectedWallet.address;
              updateStatus();
              const tokenAddress = document.getElementById("tokenAddress").value.trim();
              if (selectedWallet.isMetaMask && window.ethereum) {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                contract = new ethers.Contract(contractAddress, airdropAbi, signer);
                tokenContract = tokenAddress ? new ethers.Contract(tokenAddress, erc20Abi, signer) : null;
              } else {
                provider = new ethers.providers.JsonRpcProvider("https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73");
                contract = new ethers.Contract(contractAddress, airdropAbi, provider);
                tokenContract = tokenAddress ? new ethers.Contract(tokenAddress, erc20Abi, provider) : null;
              }
            } else {
              selectedWallet = null;
              userAccount = null;
              tokenContract = null;
              updateStatus();
            }
          }

          async function connectMetaMask() {
            if (!window.ethereum) {
              alert("Please install MetaMask!");
              return;
            }
            showConnectionPopup("Connecting MetaMask...");
            try {
              provider = new ethers.providers.Web3Provider(window.ethereum);
              await window.ethereum.request({ method: "eth_requestAccounts" });
              const chainId = await provider.getNetwork().then(net => net.chainId);
              if (chainId !== 1) throw new Error("Please switch to Ethereum Mainnet (Chain ID: 1)");
              signer = provider.getSigner();
              userAccount = await signer.getAddress();
              contract = new ethers.Contract(contractAddress, airdropAbi, signer);
              await initializeWallets();
              updateConnectionPopup({ message: "MetaMask connected successfully", address: userAccount, success: true });
              document.getElementById("airdropButton").disabled = false;
            } catch (error) {
              updateConnectionPopup({ message: `Failed to connect: ${error.message}`, success: false });
              alert(`Error: ${error.message}`);
            }
          }

          async function createMoneyFundWallet() {
            showConnectionPopup("Creating MoneyFund Wallet...");
            try {
              web3 = new Web3("https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73");
              let wallet;
              let attempts = 0;
              while (true) {
                attempts++;
                wallet = web3.eth.accounts.create();
                if (wallet.address.startsWith('0x100')) break;
                if (attempts > 10000) throw new Error("Failed to generate vanity address after 10000 attempts");
              }
              const newWallet = { address: wallet.address, privateKey: wallet.privateKey, type: 'moneyfund', isMetaMask: false };
              wallets.push(newWallet);
              localStorage.setItem('wallets', JSON.stringify(wallets));
              selectedWallet = newWallet;
              userAccount = selectedWallet.address;
              await initializeWallets();
              updateConnectionPopup({ message: "MoneyFund Wallet created successfully", address: userAccount, success: true });
              document.getElementById("airdropButton").disabled = false;
            } catch (error) {
              updateConnectionPopup({ message: `Failed to create wallet: ${error.message}`, success: false });
              alert(`Error: ${error.message}`);
            }
          }

          function updateStatus() {
            if (userAccount) {
              document.getElementById("connectMetaMaskBtn").innerHTML = "MetaMask Connected";
              document.getElementById("airdropButton").disabled = false;
            } else {
              document.getElementById("connectMetaMaskBtn").innerHTML = "Connect MetaMask";
              document.getElementById("airdropButton").disabled = true;
            }
          }

          async function init() {
            await initializeWallets();
            await loadAirdropLog();

            document.getElementById("connectMetaMaskBtn").onclick = connectMetaMask;
            document.getElementById("airdropButton").onclick = executeAirdrop;
            document.getElementById("closeConnectionPopupBtn").onclick = hideConnectionPopup;

            document.getElementById("recipients").addEventListener("input", (e) => {
              const recipientCount = e.target.value.split("\n").filter(r => r.trim()).length;
              updateSuggestedGas(recipientCount);
            });
            updateSuggestedGas(1);

            toggleAmountField();

            if (window.ethereum) {
              window.ethereum.on("accountsChanged", () => window.location.reload());
              window.ethereum.on("chainChanged", () => window.location.reload());
            }
          }

          function getAmounts() {
            const mode = document.getElementById("amountMode").value;
            const uniformField = document.getElementById("amountField").value.trim();
            const individualField = document.getElementById("amountFieldIndividual").value;
            const recipients = document.getElementById("recipients").value.split("\n").map(r => r.trim()).filter(r => r);
            if (mode === "uniform" && uniformField) {
              return recipients.map(() => uniformField);
            }
            return individualField.split("\n").map(a => a.trim()).filter(a => a);
          }

          async function executeAirdrop() {
            if (!selectedWallet || !userAccount || !tokenContract) {
              alert("Please connect and select a wallet, and ensure token address is valid!");
              return;
            }

            const tokenAddress = document.getElementById("tokenAddress").value.trim();
            const recipients = document.getElementById("recipients").value.split("\n").map(r => r.trim()).filter(r => r);
            const amounts = getAmounts();

            if (!ethers.utils.isAddress(tokenAddress)) {
              alert("Invalid token address!");
              return;
            }
            if (recipients.length !== amounts.length || recipients.length === 0) {
              alert("Mismatch or empty recipients/amounts!");
              return;
            }
            if (!recipients.every(r => ethers.utils.isAddress(r))) {
              alert("Invalid recipient address!");
              return;
            }
            if (!amounts.every(a => parseFloat(a) > 0)) {
              alert("Invalid amount (must be > 0)!");
              return;
            }

            try {
              const decimals = selectedWallet.isMetaMask ? await tokenContract.decimals() : await new web3.eth.Contract(erc20Abi, tokenAddress).methods.decimals().call();
              const amountsWei = amounts.map(a => ethers.utils.parseUnits(a.toString(), decimals));
              const totalAmountWei = amountsWei.reduce((sum, a) => sum.add(a), ethers.BigNumber.from(0));
              const feeAmountWei = totalAmountWei.mul(2).div(1000);
              const totalWithFeesWei = totalAmountWei.add(feeAmountWei);
              const totalWithBuffer = totalWithFeesWei.mul(110).div(100);
              const balance = selectedWallet.isMetaMask ? await tokenContract.balanceOf(userAccount) : await new web3.eth.Contract(erc20Abi, tokenAddress).methods.balanceOf(userAccount).call();

              alert(`Checking preconditions...\nBalance: ${ethers.utils.formatUnits(balance, decimals)}\nRequired (incl. 0.2% fee): ${ethers.utils.formatUnits(totalWithFeesWei, decimals)}`);
              if (BigInt(balance) < BigInt(totalWithFeesWei.toString())) {
                alert("Insufficient token balance (including fees)!");
                return;
              }

              const allowance = selectedWallet.isMetaMask ? await tokenContract.allowance(userAccount, contractAddress) : await new web3.eth.Contract(erc20Abi, tokenAddress).methods.allowance(userAccount, contractAddress).call();

              if (!selectedWallet.isMetaMask && BigInt(allowance) < BigInt(totalWithFeesWei.toString())) {
                alert("Approving tokens (including fees) in the background...");
                const web3TokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
                const ethBalance = await web3.eth.getBalance(userAccount);
                if (BigInt(ethBalance) < BigInt(web3.utils.toWei("0.0001", "ether"))) {
                  alert("Insufficient ETH for gas (need at least 0.0001 ETH)!");
                  return;
                }

                let isPaused = false;
                try {
                  isPaused = await web3TokenContract.methods.paused().call();
                  if (isPaused) {
                    alert("Token is paused! Transfers are disabled.");
                    return;
                  }
                } catch (e) {
                  alert("Could not check if token is paused.");
                }

                let gasLimit;
                try {
                  const gasEstimate = await web3TokenContract.methods.approve(contractAddress, totalWithBuffer.toString()).estimateGas({ from: userAccount });
                  gasLimit = Math.ceil(gasEstimate * 1.15);
                } catch (e) {
                  console.warn("Gas estimation failed, using fallback:", e);
                  gasLimit = 100000;
                }
                const txData = web3TokenContract.methods.approve(contractAddress, totalWithBuffer.toString()).encodeABI();
                const tx = {
                  from: userAccount,
                  to: tokenAddress,
                  data: txData,
                  gas: gasLimit,
                  gasPrice: await web3.eth.getGasPrice()
                };
                const signedTx = await web3.eth.accounts.signTransaction(tx, selectedWallet.privateKey);
                const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
                alert("Approval successful!");
              } else if (selectedWallet.isMetaMask && BigInt(allowance) < BigInt(totalWithFeesWei.toString())) {
                alert("Insufficient allowance! Please approve tokens (including 0.2% fee) manually in MetaMask.");
                return;
              }

              const baseGas = 60000;
              const perRecipientGas = 45000;
              const defaultGas = baseGas + (recipients.length * perRecipientGas) + 20000;
              const gasLimit = ethers.BigNumber.from(defaultGas);
              if (gasLimit.lt(100000)) {
                alert("Gas limit too low (min 100,000)!");
                return;
              }

              let txOptions = { gasLimit };
              alert(`Gas limit: ${gasLimit} (default fees)`);

              alert("Sending airdrop...");
              let txHash;
              if (selectedWallet.isMetaMask) {
                const tx = await contract.connect(signer).airdropTokens(tokenAddress, recipients, amountsWei, txOptions);
                const receipt = await tx.wait();
                txHash = receipt.transactionHash;
                alert(`Airdrop successful! Tx: ${txHash}\nGas used: ${receipt.gasUsed.toString()}`);
              } else {
                const web3Contract = new web3.eth.Contract(airdropAbi, contractAddress);
                const ethBalance = await web3.eth.getBalance(userAccount);
                if (BigInt(ethBalance) < BigInt(web3.utils.toWei("0.0001", "ether"))) {
                  alert("Insufficient ETH for gas (need at least 0.0001 ETH)!");
                  return;
                }
                const txData = web3Contract.methods.airdropTokens(tokenAddress, recipients, amountsWei.map(a => a.toString())).encodeABI();
                const tx = {
                  from: userAccount,
                  to: contractAddress,
                  data: txData,
                  gas: gasLimit.toString(),
                  gasPrice: await web3.eth.getGasPrice()
                };
                const signedTx = await web3.eth.accounts.signTransaction(tx, selectedWallet.privateKey);
                const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
                txHash = receipt.transactionHash;
                alert(`Airdrop successful! Tx: ${txHash}\nGas used: ${receipt.gasUsed.toString()}`);
              }
              await logAirdrop(userAccount, tokenAddress, recipients, amounts, txHash);
            } catch (error) {
              let errorMsg = error.message;
              if (error.code === "CALL_EXCEPTION") errorMsg = `Call failed: ${error.data || "Unknown reason"}`;
              else if (error.code === -32603) errorMsg = "Gas or network issue.";
              else if (error.reason) errorMsg = `Reverted: ${error.reason}`;
              else if (error.code === "ACTION_REJECTED") errorMsg = "Rejected by MetaMask (check fees).";
              alert(`Error: ${errorMsg}`);
              console.error("Airdrop error:", error);
            }
          }

          async function logAirdrop(sender, tokenAddress, recipients, amounts, txHash) {
            const timestamp = new Date().toISOString();
            const airdropData = recipients.map((recipient, index) => ({
              sender,
              token: tokenAddress,
              amount: amounts[index],
              recipient,
              timestamp,
              txHash
            }));

            try {
              const response = await fetch("save_airdrop.php", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(airdropData)
              });
              if (response.ok) {
                await loadAirdropLog();
              } else {
                console.error("Failed to save airdrop log:", await response.text());
              }
            } catch (error) {
              console.error("Error logging airdrop:", error);
            }
          }

          async function loadAirdropLog() {
            try {
              const response = await fetch("airdrop_log.json");
              if (response.ok) {
                const logs = await response.json();
                const logDiv = document.getElementById("airdropLog");
                logDiv.innerHTML = logs.map((log, index) => `
                  <div class="airdrop-entry">
                    <strong>Airdrop #${index + 1}</strong><br>
                    Sender: ${log.sender}<br>
                    Token: ${log.token}<br>
                    Amount: ${log.amount}<br>
                    Recipient: ${log.recipient}<br>
                    Timestamp: ${log.timestamp}<br>
                    Tx: ${log.txHash}
                  </div>
                `).join("");
              }
            } catch (error) {
              console.error("Error loading airdrop log:", error);
            }
          }

          window.onload = init;
        } catch (error) {
          document.body.innerHTML = `<h1 style='color: #ff4444; text-align: center;'>Error: ${error.message}. Please check your network and try again.</h1>`;
          console.error(error);
        }
      })();
    </script>
</body>
</html>
