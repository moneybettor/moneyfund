<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MoneyFund Stablecoin Interface</title>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.6.0/dist/web3.min.js"></script>
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #E8ECEF;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    #backgroundCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .interface-wrapper {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 auto;
    }

    #ticker-tape {
      width: 100%;
      height: 30px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
      z-index: 1;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .ticker-content {
      display: flex;
      white-space: nowrap;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      animation: ticker-scroll linear infinite;
    }

    .ticker-item {
      margin-right: 30px;
      font-size: 14px;
      font-weight: 500;
      color: #E8ECEF;
      line-height: 5px; /* Adjusted to match ticker height for vertical centering */
    }

    @keyframes ticker-scroll {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%); /* Move half the content width for seamless loop */
      }
    }

    .container {
      background: rgba(255, 255, 255, 0.05);
      padding: 30px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100%;
      max-width: 600px;
      z-index: 1;
      margin-top: 10px;
    }

    h1 {
      text-align: center;
      color: #FFFFFF;
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: 600;
    }

    label {
      display: block;
      margin: 10px 0 5px;
      font-weight: 500;
      color: #E8ECEF;
    }

    select, input {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      font-size: 16px;
      color: #E8ECEF;
      background: rgba(255, 255, 255, 0.1);
      transition: border-color 0.3s ease, background 0.3s ease;
    }

    select:hover, input:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    input::placeholder {
      color: #A3BFFA;
      opacity: 0.7;
    }

    button {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    #mintDollarBtn, #burnDollarBtn {
      background: #3B82F6;
      color: #FFFFFF;
    }

    #mintDollarBtn:hover, #burnDollarBtn:hover {
      background: #2563EB;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
    }

    #status {
      margin-top: 20px;
      font-weight: 500;
      text-align: center;
      color: #E8ECEF;
    }

    #log {
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 10px;
      font-size: 14px;
      background: rgba(255, 255, 255, 0.05);
      color: #E8ECEF;
      border-radius: 6px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    #balances {
      margin: 0 auto 20px; /* Center horizontally with auto margins */
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      color: #E8ECEF;
      width: fit-content; /* Shrink-wrap to content */
      text-align: center; /* Center text inside */
    }

    #balances p {
      margin: 5px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="backgroundCanvas"></canvas>
  <div class="interface-wrapper">
    <div id="ticker-tape">
      <div class="ticker-content"></div>
    </div>
    <div class="container">
      <h1>MoneyFund Stablecoin</h1>
      <div id="balances">
        <p>My USDM Balance: <span id="dollarBalance">0</span></p>
        <p>1 USDM Price: $<span id="dollarPrice">1.0000</span></p>
      </div>
      <label for="walletSelector">Select Wallet:</label>
      <select id="walletSelector" onchange="dollarInterface.selectWallet(this.value)">
        <option value="">-- Select Wallet --</option>
      </select>
      <label for="mintAmount">Mint USDM Amount:</label>
      <input type="number" id="mintAmount" placeholder="e.g., 10" step="0.01" min="0">
      <button id="mintDollarBtn">Mint USDM</button>
      <label for="burnAmount">Burn USDM Amount:</label>
      <input type="number" id="burnAmount" placeholder="e.g., 10" step="0.01" min="0">
      <button id="burnDollarBtn">Burn USDM</button>
      <div id="status">Status: Not started</div>
      <div id="log"></div>
    </div>
  </div>

  <script>
    // Background 3D Space with Green Particles and Random Behaviors
    const canvas = document.getElementById('backgroundCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const particles = [];
    const numParticles = 300;
    const maxZ = 1000;
    const focalLength = 500;

    const greenShades = [
      '#006400', '#228B22', '#32CD32', '#3CB371', '#2E8B57',
      '#9ACD32', '#66CDAA', '#00FF7F', '#7CFC00', '#ADFF2F',
      '#00FA9A', '#90EE90', '#98FB98', '#8FBC8F'
    ];

    class Particle {
      constructor(isExplosionParticle = false, lifespan = Infinity) {
        this.x = (Math.random() - 0.5) * canvas.width * 2;
        this.y = (Math.random() - 0.5) * canvas.height * 2;
        this.z = Math.random() * maxZ;
        this.vx = isExplosionParticle ? (Math.random() - 0.5) * 5 : (Math.random() - 0.5) * 2;
        this.vy = isExplosionParticle ? (Math.random() - 0.5) * 5 : (Math.random() - 0.5) * 2;
        this.vz = isExplosionParticle ? (Math.random() - 0.5) * 2 : (Math.random() - 0.5) * 1;
        this.size = isExplosionParticle ? 1 : 2;
        this.color = greenShades[Math.floor(Math.random() * greenShades.length)];
        this.isShooting = false;
        this.isExploding = false;
        this.lifespan = lifespan;
        this.age = 0;
        this.behaviorEndTime = 0;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.z += this.vz;

        if (this.x < -canvas.width) this.x = canvas.width;
        if (this.x > canvas.width) this.x = -canvas.width;
        if (this.y < -canvas.height) this.y = canvas.height;
        if (this.y > canvas.height) this.y = -canvas.height;

        if (this.z < 1) this.z = maxZ;
        if (this.z > maxZ) this.z = 1;

        if (this.lifespan !== Infinity) {
          this.age++;
        }
      }

      draw() {
        const scale = focalLength / (focalLength + this.z);
        const x2d = (this.x * scale) + canvas.width / 2;
        const y2d = (this.y * scale) + canvas.height / 2;
        const scaledSize = this.size * scale;

        const container = document.querySelector('.container');
        const rect = container ? container.getBoundingClientRect() : { left: 0, right: 0, top: 0, bottom: 0 };

        const isInsideBox = x2d >= rect.left && x2d <= rect.right && y2d >= rect.top && y2d <= rect.bottom;

        if (!isInsideBox && this.age < this.lifespan) {
          const opacity = this.lifespan === Infinity ? (1 - this.z / maxZ) : (1 - this.age / this.lifespan);
          ctx.save();
          ctx.fillStyle = this.color;
          ctx.globalAlpha = opacity;
          ctx.beginPath();
          ctx.arc(x2d, y2d, scaledSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    for (let i = 0; i < numParticles; i++) {
      particles.push(new Particle());
    }

    function createBackgroundGradient() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1C2526');
      gradient.addColorStop(1, '#2E1A47');
      return gradient;
    }

    const activeBehaviorParticles = new Set();
    const maxBehaviors = 2;

    function applyRandomBehavior() {
      const now = Date.now();

      for (let particle of activeBehaviorParticles) {
        if (now >= particle.behaviorEndTime) {
          particle.isShooting = false;
          particle.isExploding = false;
          particle.vx = (Math.random() - 0.5) * 2;
          particle.vy = (Math.random() - 0.5) * 2;
          activeBehaviorParticles.delete(particle);
        }
      }

      while (activeBehaviorParticles.size < maxBehaviors) {
        const availableParticles = particles.filter(p => !activeBehaviorParticles.has(p) && p.lifespan === Infinity);
        if (availableParticles.length === 0) break;

        const particle = availableParticles[Math.floor(Math.random() * availableParticles.length)];
        const behavior = Math.random() < 0.5 ? 'shoot' : 'explode';

        if (behavior === 'shoot') {
          particle.isShooting = true;
          particle.vx = (Math.random() - 0.5) * 20;
          particle.vy = (Math.random() - 0.5) * 20;
          particle.behaviorEndTime = now + 1000;
          activeBehaviorParticles.add(particle);
        } else {
          particle.isExploding = true;
          const numExplosionParticles = 5;
          for (let i = 0; i < numExplosionParticles; i++) {
            const explosionParticle = new Particle(true, 60);
            explosionParticle.x = particle.x;
            explosionParticle.y = particle.y;
            explosionParticle.z = particle.z;
            particles.push(explosionParticle);
          }
          particle.lifespan = 1;
          particle.age = 0;
          particle.behaviorEndTime = now + 1000;
          activeBehaviorParticles.add(particle);
        }
      }
    }

    let lastFrameTime = Date.now();
    const targetFrameInterval = 1000 / 60;

    function animateSpace() {
      const now = Date.now();
      const deltaTime = now - lastFrameTime;

      if (deltaTime < targetFrameInterval) {
        requestAnimationFrame(animateSpace);
        return;
      }
      lastFrameTime = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = createBackgroundGradient();
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach((particle, index) => {
        particle.update();
        particle.draw();
        if (particle.age >= particle.lifespan) {
          particles.splice(index, 1);
        }
      });

      applyRandomBehavior();
      requestAnimationFrame(animateSpace);
    }

    animateSpace();

    let selectedWallet = null;

    function logMessage(message) {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('p');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function updateStatus(message) {
      document.getElementById('status').textContent = `Status: ${message}`;
    }

    class DollarInterface {
      constructor() {
        this.web3 = new Web3("https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73");
        this.contractAddress = "0x33d5be7c0584f77b3168b1d38e1a6215af242d4f"
        this.contractABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "etfAmount",
				"type": "uint256"
			}
		],
		"name": "burn",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "allowance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientAllowance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "balance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientBalance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "approver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidApprover",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidReceiver",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSpender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "etfAmount",
				"type": "uint256"
			}
		],
		"name": "mintWithEth",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "ReentrancyGuardReentrantCall",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "user",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "etfAmount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "ethReceived",
				"type": "uint256"
			}
		],
		"name": "Burned",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "tokenAmount",
				"type": "uint256"
			}
		],
		"name": "FeeCollected",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "user",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "etfAmount",
				"type": "uint256"
			}
		],
		"name": "Minted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "tokenAmount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "minEthOut",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "success",
				"type": "bool"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "reason",
				"type": "string"
			}
		],
		"name": "SwapAttempt",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "TokenBurned",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transfer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "allowance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "basket",
		"outputs": [
			{
				"internalType": "address",
				"name": "tokenAddress",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "weight",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenAmount",
				"type": "uint256"
			}
		],
		"name": "calculateMinEthOut",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "ethAmount",
				"type": "uint256"
			}
		],
		"name": "calculateMinTokenOut",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "DEAD_ADDRESS",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "decimals",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "ETH_BUFFER",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "FEE_BASIS_POINTS",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "feeReceiver",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "feeReceiver2",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getEthBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getEthPrice",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "returnPrice",
				"type": "bool"
			}
		],
		"name": "getPriceOrGain",
		"outputs": [
			{
				"internalType": "int256",
				"name": "",
				"type": "int256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getWeiPerEtf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "PRICE_FEED_DECIMALS",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceFeed",
		"outputs": [
			{
				"internalType": "contract AggregatorV3Interface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "SLIPPAGE_PROTECTION",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "SWAP_DEADLINE",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "TOKENX",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "TOTAL_BASIS_POINTS",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "uniswapRouter",
		"outputs": [
			{
				"internalType": "contract IUniswapV2Router02",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "WEI_PER_ETH",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "weth",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];
        this.contract = new this.web3.eth.Contract(this.contractABI, this.contractAddress);
        this.wallets = [];
        this.defaultGasLimit = 1500000; // Kept original gas limit as fallback
        // Constants for calculation
        this.ETH_BUFFER = 1005; // 0.5% buffer

        // Basket assets with names, tickers, and weights (from contract constructor)
        this.basketAssets = [
          { name: 'USD Coin', ticker: 'USDC', weight: 3333 }, // 33.33%
          { name: 'Tether', ticker: 'USDT', weight: 3333 }, // 33.33%
          { name: 'Dai', ticker: 'DAI', weight: 3334 } // 33.34%
        ];
      }

      init() {
        this.loadWalletsFromStorage();
        this.attachEventListeners();
        this.updateBalances();
        this.setupTickerTape();
      }

      setupTickerTape() {
        const tickerContent = document.querySelector('.ticker-content');
        // Quadruple assets for seamless looping
        const assets = [...this.basketAssets, ...this.basketAssets, ...this.basketAssets, ...this.basketAssets];
        assets.forEach(asset => {
          const tickerItem = document.createElement('span');
          tickerItem.className = 'ticker-item';
          const weightPercent = (asset.weight / 100).toFixed(2);
          tickerItem.textContent = `${asset.name} (${asset.ticker}) ${weightPercent}%`;
          tickerContent.appendChild(tickerItem);
        });

        // Set animation duration based on original number of assets (4 seconds per asset)
        const animationDuration = this.basketAssets.length * 4;
        tickerContent.style.animationDuration = `${animationDuration}s`;
      }

      attachEventListeners() {
        document.getElementById('mintDollarBtn').addEventListener('click', () => this.mintDollar());
        document.getElementById('burnDollarBtn').addEventListener('click', () => this.burnDollar());
        document.getElementById('mintAmount').addEventListener('input', () => this.updateMintInfo());
      }

      loadWalletsFromStorage() {
        this.wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
        const selector = document.getElementById('walletSelector');
        selector.innerHTML = '<option value="">-- Select Wallet --</option>';
        this.wallets.forEach((wallet, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = `${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
          selector.appendChild(option);
        });
        logMessage(`Loaded ${this.wallets.length} wallets from localStorage.`);

        if (this.wallets.length > 0) {
          selectedWallet = this.wallets[0];
          document.getElementById('walletSelector').value = 0;
          logMessage(`Automatically selected wallet: ${selectedWallet.address}`);
          this.updateBalances();
        }
      }

      selectWallet(index) {
        const idx = parseInt(index);
        if (idx >= 0 && idx < this.wallets.length) {
          selectedWallet = this.wallets[idx];
          logMessage(`Selected wallet: ${selectedWallet.address}`);
          this.updateBalances();
        } else {
          selectedWallet = null;
          logMessage("No wallet selected.");
          document.getElementById('dollarBalance').textContent = '0';
          document.getElementById('dollarPrice').textContent = '1.0000';
        }
      }

      async waitForReceipt(txHash) {
        let receipt = null;
        let attempts = 0;
        const maxAttempts = 30;
        while (!receipt && attempts < maxAttempts) {
          try {
            receipt = await this.web3.eth.getTransactionReceipt(txHash);
            if (!receipt) {
              await new Promise(resolve => setTimeout(resolve, 10000));
              attempts++;
            }
          } catch (error) {
            logMessage(`Error fetching receipt for ${txHash}: ${error.message}`);
            return null;
          }
        }
        if (!receipt) {
          logMessage(`No receipt found for ${txHash} after ${maxAttempts} attempts.`);
        }
        return receipt;
      }

      async updateBalances() {
        if (!selectedWallet) {
          logMessage("No wallet selected for updating balances.");
          document.getElementById('dollarBalance').textContent = '0';
          document.getElementById('dollarPrice').textContent = '1.0000';
          return;
        }
        try {
          // Fetch USDM Balance
          const dollarBalance = this.web3.utils.fromWei(
            await this.contract.methods.balanceOf(selectedWallet.address).call(),
            'ether'
          );
          document.getElementById('dollarBalance').textContent = parseFloat(dollarBalance).toFixed(4);
          logMessage(`USDM Balance: ${dollarBalance}`);

          // Fetch USDM Price (in USD, 18 decimals)
          const priceWei = await this.contract.methods.getPriceOrGain(true).call();
          const priceUsd = this.web3.utils.fromWei(priceWei.toString(), 'ether');
          document.getElementById('dollarPrice').textContent = parseFloat(priceUsd).toFixed(4);
          logMessage(`USDM Price: $${priceUsd}`);
        } catch (error) {
          logMessage(`Error updating balances: ${error.message}`);
          document.getElementById('dollarBalance').textContent = '0';
          document.getElementById('dollarPrice').textContent = '1.0000';
        }
      }

      async updateMintInfo() {
        const dollarAmount = document.getElementById('mintAmount').value;
        if (dollarAmount > 0) {
          try {
            const dollarAmountWei = this.web3.utils.toWei(dollarAmount.toString(), 'ether');
            const weiPerUsdm = await this.contract.methods.getWeiPerEtf().call();

            // Calculate ETH needed for minting
            const ethRequired = this.web3.utils.toBN(weiPerUsdm)
              .mul(this.web3.utils.toBN(dollarAmountWei))
              .div(this.web3.utils.toBN('1000000000000000000'));
            const ethRequiredWithBuffer = ethRequired
              .mul(this.web3.utils.toBN(this.ETH_BUFFER))
              .div(this.web3.utils.toBN(1000)); // 0.5% buffer

            // Calculate 0.2% USDM fee (0.1% per receiver)
            const feeAmount = this.web3.utils.toBN(dollarAmountWei)
              .mul(this.web3.utils.toBN(10))
              .div(this.web3.utils.toBN(10000));
            const totalFeeAmount = feeAmount.mul(this.web3.utils.toBN(2));
            const feeAmountEth = this.web3.utils.fromWei(totalFeeAmount, 'ether');

            logMessage(
              `To mint ${dollarAmount} USDM: ~${this.web3.utils.fromWei(ethRequiredWithBuffer, 'ether')} ETH needed (swapped to USDC, USDT, DAI). Fees: ${feeAmountEth} USDM (0.1% to each receiver).`
            );
          } catch (error) {
            logMessage(`Error in updateMintInfo: ${error.message}`);
          }
        }
      }

      async mintDollar() {
        if (!selectedWallet) {
          logMessage("Please select a wallet.");
          updateStatus("Please select a wallet.");
          return;
        }
        const dollarAmount = document.getElementById('mintAmount').value;
        if (!dollarAmount || dollarAmount <= 0) {
          logMessage("Please enter a valid USDM amount.");
          updateStatus("Please enter a valid USDM amount.");
          return;
        }
        const dollarAmountWei = this.web3.utils.toWei(dollarAmount.toString(), 'ether');
        try {
          updateStatus("Preparing to mint USDM...");

          // Check wallet balance
          const walletBalance = await this.web3.eth.getBalance(selectedWallet.address);
          const walletBalanceEth = this.web3.utils.fromWei(walletBalance, 'ether');
          logMessage(`Wallet ETH balance: ${walletBalanceEth}`);

          // Calculate ETH needed
          const weiPerUsdm = await this.contract.methods.getWeiPerEtf().call();
          const ethRequired = this.web3.utils.toBN(weiPerUsdm)
            .mul(this.web3.utils.toBN(dollarAmountWei))
            .div(this.web3.utils.toBN('1000000000000000000'));
          const ethRequiredWithBuffer = ethRequired
            .mul(this.web3.utils.toBN(this.ETH_BUFFER))
            .div(this.web3.utils.toBN(1000)); // 0.5% buffer

          // Estimate gas
          let gasLimit = this.defaultGasLimit;
          try {
            gasLimit = await this.contract.methods.mintWithEth(dollarAmountWei).estimateGas({
              from: selectedWallet.address,
              value: ethRequiredWithBuffer.toString()
            });
            // Add 20% buffer to estimated gas
            gasLimit = Math.floor(gasLimit * 1.2);
            logMessage(`Estimated gas limit: ${gasLimit}`);
          } catch (error) {
            logMessage(`Gas estimation failed, using default ${gasLimit}: ${error.message}`);
          }

          const gasPrice = await this.web3.eth.getGasPrice();
          logMessage(`Gas price: ${this.web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

          // Calculate total cost (value + gas)
          const gasCost = this.web3.utils.toBN(gasPrice).mul(this.web3.utils.toBN(gasLimit));
          const totalCost = ethRequiredWithBuffer.add(gasCost);

          // Validate balance
          if (this.web3.utils.toBN(walletBalance).lt(totalCost)) {
            throw new Error(
              `Insufficient ETH: need ${this.web3.utils.fromWei(totalCost, 'ether')} ETH (value + gas), have ${walletBalanceEth} ETH`
            );
          }

          updateStatus("Minting USDM...");
          const tx = {
            from: selectedWallet.address,
            to: this.contractAddress,
            data: this.contract.methods.mintWithEth(dollarAmountWei).encodeABI(),
            value: ethRequiredWithBuffer.toString(),
            gas: gasLimit,
            gasPrice
          };

          // Validate private key
          if (!selectedWallet.privateKey || !selectedWallet.privateKey.startsWith('0x') || selectedWallet.privateKey.length !== 66) {
            throw new Error("Invalid private key format");
          }

          const signedTx = await this.web3.eth.accounts.signTransaction(tx, selectedWallet.privateKey);
          const txHash = await new Promise((resolve, reject) => {
            this.web3.eth.sendSignedTransaction(signedTx.rawTransaction)
              .on('transactionHash', hash => {
                logMessage(`Mint transaction hash: ${hash}`);
                resolve(hash);
              })
              .on('error', error => {
                logMessage(`Error sending mint transaction: ${error.message}`);
                reject(error);
              });
          });

          logMessage(`Mint transaction sent for ${dollarAmount} USDM: ${txHash}`);
          const receipt = await this.waitForReceipt(txHash);
          if (receipt && receipt.status) {
            logMessage(`Minted ${dollarAmount} USDM successfully.`);
            updateStatus(`Minted ${dollarAmount} USDM successfully.`);
            await this.updateBalances();
          } else {
            logMessage("Mint transaction reverted.");
            updateStatus("Mint transaction reverted.");
          }
        } catch (error) {
          logMessage(`Mint failed: ${error.message}`);
          updateStatus(`Mint failed: ${error.message}`);
        }
      }

      async burnDollar() {
        if (!selectedWallet) {
          logMessage("Please select a wallet.");
          updateStatus("Please select a wallet.");
          return;
        }
        const dollarAmount = document.getElementById('burnAmount').value;
        if (!dollarAmount || dollarAmount <= 0) {
          logMessage("Please enter a valid USDM amount.");
          updateStatus("Please enter a valid USDM amount.");
          return;
        }
        const dollarAmountWei = this.web3.utils.toWei(dollarAmount.toString(), 'ether');
        try {
          updateStatus("Burning USDM...");

          // Check USDM balance
          const dollarBalance = await this.contract.methods.balanceOf(selectedWallet.address).call();
          if (this.web3.utils.toBN(dollarBalance).lt(this.web3.utils.toBN(dollarAmountWei))) {
            throw new Error(
              `Insufficient USDM balance: need ${dollarAmount} USDM, have ${this.web3.utils.fromWei(dollarBalance, 'ether')} USDM`
            );
          }

          // Calculate 0.2% USDM fee (0.1% per receiver)
          const feeAmount = this.web3.utils.toBN(dollarAmountWei)
            .mul(this.web3.utils.toBN(10))
            .div(this.web3.utils.toBN(10000));
          const totalFeeAmount = feeAmount.mul(this.web3.utils.toBN(2));
          const usdmToBurn = this.web3.utils.toBN(dollarAmountWei).sub(totalFeeAmount);

          // Estimate ETH output
          const weiPerUsdm = await this.contract.methods.getWeiPerEtf().call();
          const expectedEthOut = this.web3.utils.toBN(weiPerUsdm)
            .mul(this.web3.utils.toBN(usdmToBurn))
            .div(this.web3.utils.toBN('1000000000000000000'));

          logMessage(
            `Burning ${dollarAmount} USDM to receive ~${this.web3.utils.fromWei(expectedEthOut, 'ether')} ETH (after ${this.web3.utils.fromWei(totalFeeAmount, 'ether')} USDM fees).`
          );

          // Estimate gas
          let gasLimit = this.defaultGasLimit;
          try {
            gasLimit = await this.contract.methods.burn(dollarAmountWei).estimateGas({
              from: selectedWallet.address
            });
            // Add 20% buffer to estimated gas
            gasLimit = Math.floor(gasLimit * 1.2);
            logMessage(`Estimated gas limit: ${gasLimit}`);
          } catch (error) {
            logMessage(`Gas estimation failed, using default ${gasLimit}: ${error.message}`);
          }

          const gasPrice = await this.web3.eth.getGasPrice();
          logMessage(`Gas price: ${this.web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

          const tx = {
            from: selectedWallet.address,
            to: this.contractAddress,
            data: this.contract.methods.burn(dollarAmountWei).encodeABI(),
            gas: gasLimit,
            gasPrice
          };

          const signedTx = await this.web3.eth.accounts.signTransaction(tx, selectedWallet.privateKey);
          const txHash = await new Promise((resolve, reject) => {
            this.web3.eth.sendSignedTransaction(signedTx.rawTransaction)
              .on('transactionHash', hash => {
                logMessage(`Burn transaction hash: ${hash}`);
                resolve(hash);
              })
              .on('error', error => {
                logMessage(`Error sending burn transaction: ${error.message}`);
                reject(error);
              });
          });

          logMessage(`Burn transaction sent for ${dollarAmount} USDM: ${txHash}`);
          const receipt = await this.waitForReceipt(txHash);
          if (receipt && receipt.status) {
            logMessage(`Burned ${dollarAmount} USDM successfully.`);
            updateStatus(`Burned ${dollarAmount} USDM successfully.`);
            await this.updateBalances();
          } else {
            logMessage("Burn transaction reverted.");
            updateStatus("Burn transaction reverted.");
          }
        } catch (error) {
          logMessage(`Burn failed: ${error.message}`);
          updateStatus(`Burn failed: ${error.message}`);
        }
      }
    }

    const dollarInterface = new DollarInterface();
    dollarInterface.init();
  </script>
</body>
</html>
