<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoneyFund DAO Launchpad</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #E5E7EB;
            padding: 20px;
            min-height: 100vh;
            line-height: 1.5;
            background: linear-gradient(135deg, #0A0C1E, #1F2A44);
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" opacity="0.03"%3E%3Cdefs%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.7" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3C/defs%3E%3Crect width="100%" height="100%" filter="url(%23noise)"/%3E%3C/svg%3E');
            z-index: -1;
        }

        .flex-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .full-width-container {
            flex: 1;
            min-width: 0;
            padding: 15px;
            background: rgba(31, 41, 55, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            margin-bottom: 15px;
        }

        .launch-dao-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
        }

        .bottom-bar {
            max-width: 1200px;
            margin: 15px auto;
            background: rgba(31, 41, 55, 0.6);
            border: 1px solid rgba(99, 102, 241, 0.2);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .bottom-bar-content {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 1200px;
            flex-wrap: nowrap;
            justify-content: space-between;
        }

        button {
            padding: 14px;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            background: linear-gradient(90deg, #4F46E5, #A855F7);
            color: #F9FAFB;
            font-weight: 600;
            font-size: 1.1rem;
            transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
            text-align: center;
        }

        button:hover {
            background: linear-gradient(90deg, #4338CA, #9333EA);
            transform: scale(1.03);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
        }

        button:active::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            transform: scale(1);
            transition: transform 0.2s;
        }

        #connect-wallet-button, #launch-dao-button {
            padding: 12px 20px;
            margin: 5px;
            font-size: 0.95rem;
        }

        .copy-button {
            padding: 3px 6px;
            font-size: 0.75rem;
            background: #4B5EAA;
            margin-left: 5px;
        }

        .copy-button:hover {
            background: #3B4A8C;
            transform: scale(1.02);
        }

        input, select {
            padding: 8px;
            margin: 3px 0;
            width: 100%;
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 6px;
            background: rgba(17, 24, 39, 0.9);
            color: #E5E7EB;
            font-size: 0.95rem;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        input:hover, select:hover {
            background: rgba(17, 24, 39, 0.95);
            border-color: rgba(99, 102, 241, 0.4);
        }

        input::placeholder {
            color: #9CA3AF;
            opacity: 0.8;
        }

        select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23E5E7EB%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 8px auto;
            padding-right: 25px;
            max-width: 180px;
        }

        h2, h3 {
            color: #FFFFFF;
            text-align: center;
            word-wrap: break-word;
        }

        h2 { font-size: 1.6em; margin-bottom: 8px; }
        h3 { font-size: 1.2em; margin: 8px 0 6px; }

        #walletAddress {
            font-size: 0.85em;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            color: #E5E7EB;
            margin: 5px;
        }

        label {
            color: #E5E7EB;
            margin: 5px 0 2px;
            display: block;
            font-weight: 600;
            text-align: left;
            font-size: 0.85em;
        }

        .status-message, .error-message {
            margin-top: 5px;
            font-size: 0.8em;
            text-align: center;
            padding: 6px;
            border-radius: 4px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            background: rgba(17, 24, 39, 0.9);
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .status-message { color: #10B981; }
        .error-message { color: #F87171; }

        #log {
            margin-top: 5px;
            max-height: 80px;
            overflow-y: auto;
            border: 1px solid rgba(99, 102, 241, 0.2);
            padding: 8px;
            font-size: 0.8em;
            background: rgba(17, 24, 39, 0.9);
            color: #E5E7EB;
            border-radius: 5px;
            width: 100%;
            max-width: 350px;
        }

        #dao-list {
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid rgba(99, 102, 241, 0.15);
            padding: 8px;
            background: rgba(17, 24, 39, 0.85);
            border-radius: 8px;
            scrollbar-width: thin;
            scrollbar-color: #6366F1 rgba(31, 41, 55, 0.5);
        }

        #dao-list::-webkit-scrollbar {
            width: 6px;
        }

        #dao-list::-webkit-scrollbar-track {
            background: rgba(31, 41, 55, 0.5);
        }

        #dao-list::-webkit-scrollbar-thumb {
            background: #6366F1;
            border-radius: 3px;
        }

        .dao-card {
            background: rgba(17, 24, 39, 0.85);
            border: 1px solid rgba(99, 102, 241, 0.15);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .dao-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .dao-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.15);
            padding-bottom: 5px;
        }

        .dao-card-header h3 {
            font-size: 1.1em;
            margin: 0;
            color: #FFFFFF;
        }

        .dao-card-header span {
            font-size: 0.95em;
            color: #6366F1;
            font-weight: 600;
        }

        .dao-card-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 8px;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .dao-card-details div {
            display: flex;
            flex-direction: column;
        }

        .dao-card-details label {
            font-weight: 600;
            color: #9CA3AF;
            margin-bottom: 1px;
        }

        .dao-card-details span {
            color: #E5E7EB;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .dao-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .proposal-form, .vote-form {
            margin-top: 10px;
            padding: 10px;
            background: rgba(31, 41, 55, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .proposal-form input, .proposal-form select,
        .vote-form input, .vote-form select {
            margin-bottom: 8px;
        }

        .proposals-list {
            margin-top: 10px;
            padding: 10px;
            background: rgba(31, 41, 55, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            font-size: 0.8em;
        }

        .proposal-item {
            margin-bottom: 8px;
            padding: 8px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.15);
        }

        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
            body { padding: 10px; }
            .flex-container { gap: 10px; padding: 0 8px; }
            .full-width-container { padding: 10px; }
            .bottom-bar { padding: 10px; }
            h2 { font-size: 1.3em; }
            h3 { font-size: 1.1em; }
            button { font-size: 0.9em; }
            input, select { font-size: 0.9em; padding: 6px; }
            #connect-wallet-button, #launch-dao-button { padding: 8px 16px; }
            #walletAddress { font-size: 0.8em; }
            .bottom-bar-content {
                flex-direction: column;
                gap: 6px;
                align-items: flex-start;
                justify-content: flex-start;
            }
            #log { max-width: 100%; }
            .dao-card-details {
                grid-template-columns: 1fr;
            }
            .dao-card {
                padding: 8px;
            }
            .dao-card-header h3 {
                font-size: 1em;
            }
            .dao-card-header span {
                font-size: 0.9em;
            }
        }

        @media (min-width: 769px) {
            .full-width-container { flex: 1; min-width: 45%; }
        }

        @media (max-width: 480px) {
            body { padding: 5px; -webkit-text-size-adjust: 100%; }
            .flex-container { padding: 0 5px; }
            .full-width-container { padding: 8px; }
            .bottom-bar { padding: 8px; }
            h2 { font-size: 1.2em; }
            h3 { font-size: 1em; }
            button { padding: 6px 10px; font-size: 0.85em; }
            input, select { padding: 5px; font-size: 0.85em; }
            #connect-wallet-button, #launch-dao-button { padding: 6px 12px; }
            #walletAddress { font-size: 0.75em; }
            .dao-card {
                padding: 6px;
            }
            .dao-card-header h3 {
                font-size: 0.95em;
            }
            .dao-card-header span {
                font-size: 0.85em;
            }
            .dao-card-details {
                font-size: 0.75em;
            }
        }

        @media (min-width: 992px) {
            .flex-container { padding: 0 10px; }
            h2 { font-size: 1.5em; }
            h3 { font-size: 1.2em; }
            #connect-wallet-button, #launch-dao-button {
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="flex-container">
        <div class="full-width-container">
            <h2>Deploy a DAO</h2>
            <label for="token-address">Token Address:</label>
            <input id="token-address" type="text" placeholder="e.g., 0xToken" />
            <label for="voting-period">Voting Period (days):</label>
            <input id="voting-period" type="number" placeholder="e.g., 1" min="1" step="1" />
            <label for="count-non-responders">Non-Responders Vote Yes:</label>
            <select id="count-non-responders">
                <option value="true">Yes</option>
                <option value="false">No</option>
            </select>
            <div class="launch-dao-container">
                <button id="launch-dao-button" onclick="createDAO()">Deploy DAO</button>
            </div>
            <p id="create-status" class="status-message"></p>
            <p id="create-error" class="error-message"></p>
        </div>

        <div class="full-width-container">
            <h2>All DAOs</h2>
            <div id="dao-list">
                <div id="dao-card-container"></div>
            </div>
            <p id="dao-status" class="status-message"></p>
        </div>
    </div>

    <div class="bottom-bar">
        <div class="bottom-bar-content">
            <button id="connect-wallet-button" onclick="connectWallet()">Connect Wallet</button>
            <select id="wallet-selector" onchange="selectWallet(this.value)">
                <option value="">-- Select Wallet --</option>
            </select>
            <p id="walletAddress">Wallet Address: Not connected</p>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // Updated contract address
        const FACTORY_ADDRESS = "0xaa80768dcd0e97e818bf624e5b1e4ca0a7cb5c82";

        // Hardcoded RPC configuration for Ethereum Mainnet
        const RPC_ENDPOINTS = [
            'https://ethereum-rpc.publicnode.com',
            'https://rpc.eth.api.onfinality.io/public',
            'https://cloudflare-eth.com',
            'https://eth-mainnet.rpcfast.com'
        ];
        let currentRpcIndex = 0;

        // DAOFactory ABI
        const daoFactoryAbi = [
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "daoAddress",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    }
                ],
                "name": "DAOCreated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "bytes",
                        "name": "reason",
                        "type": "bytes"
                    }
                ],
                "name": "DAOInitializationFailed",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_votingPeriod",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "_countNonRespondersAsYes",
                        "type": "bool"
                    }
                ],
                "name": "createDAO",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "daos",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getAllDAOs",
                "outputs": [
                    {
                        "internalType": "address[]",
                        "name": "",
                        "type": "address[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_token",
                        "type": "address"
                    }
                ],
                "name": "getDAO",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // DAO ABI
        const daoAbi = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_votingPeriod",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "_countNonRespondersAsYes",
                        "type": "bool"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    }
                ],
                "name": "SafeERC20FailedOperation",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "reason",
                        "type": "string"
                    }
                ],
                "name": "FeeCollected",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "proposalId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "proposer",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "description",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "enum DAO.ProposalType",
                        "name": "proposalType",
                        "type": "uint8"
                    }
                ],
                "name": "ProposalCreated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "proposalId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "bool",
                        "name": "passed",
                        "type": "bool"
                    }
                ],
                "name": "ProposalExecuted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "proposalId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "voter",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "bool",
                        "name": "vote",
                        "type": "bool"
                    }
                ],
                "name": "Voted",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "PROPOSAL_COOLDOWN",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "TREASURY",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "UNISWAP_V2_ROUTER",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "WITHDRAWAL_FEE_PERCENTAGE",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "countNonRespondersAsYes",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "description",
                        "type": "string"
                    },
                    {
                        "internalType": "enum DAO.ProposalType",
                        "name": "proposalType",
                        "type": "uint8"
                    },
                    {
                        "internalType": "address",
                        "name": "destination",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    }
                ],
                "name": "createProposal",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "proposalId",
                        "type": "uint256"
                    }
                ],
                "name": "executeProposal",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "factory",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getDAOInfo",
                "outputs": [
                    {
                        "components": [
                            {
                                "internalType": "address",
                                "name": "tokenAddress",
                                "type": "address"
                            },
                            {
                                "internalType": "uint256",
                                "name": "totalSupply",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "ethBalance",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "tokenBalance",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "proposalCount",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "activeProposals",
                                "type": "uint256"
                            },
                            {
                                "components": [
                                    {
                                        "internalType": "uint256",
                                        "name": "id",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "address",
                                        "name": "proposer",
                                        "type": "address"
                                    },
                                    {
                                        "internalType": "string",
                                        "name": "description",
                                        "type": "string"
                                    },
                                    {
                                        "internalType": "enum DAO.ProposalType",
                                        "name": "proposalType",
                                        "type": "uint8"
                                    },
                                    {
                                        "internalType": "address",
                                        "name": "destination",
                                        "type": "address"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "amount",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "address",
                                        "name": "tokenAddress",
                                        "type": "address"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "yesVotes",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "startTime",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "bool",
                                        "name": "executed",
                                        "type": "bool"
                                    }
                                ],
                                "internalType": "struct DAO.Proposal[]",
                                "name": "proposals",
                                "type": "tuple[]"
                            },
                            {
                                "internalType": "address",
                                "name": "uniswapRouter",
                                "type": "address"
                            },
                            {
                                "internalType": "address",
                                "name": "factory",
                                "type": "address"
                            },
                            {
                                "internalType": "uint256",
                                "name": "proposalCountPerDay",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "lastProposalTime",
                                "type": "uint256"
                            }
                        ],
                        "internalType": "struct DAO.DAOInfo",
                        "name": "",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "voter",
                        "type": "address"
                    }
                ],
                "name": "getVotingWeight",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "hasVoted",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "lastProposalTime",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "proposalCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "proposalCountPerDay",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "proposals",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "id",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "proposer",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "description",
                        "type": "string"
                    },
                    {
                        "internalType": "enum DAO.ProposalType",
                        "name": "proposalType",
                        "type": "uint8"
                    },
                    {
                        "internalType": "address",
                        "name": "destination",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "yesVotes",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "startTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "executed",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "token",
                "outputs": [
                    {
                        "internalType": "contract IERC20",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "proposalId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "support",
                        "type": "bool"
                    }
                ],
                "name": "vote",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "votingPeriod",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            }
        ];

        // Minimal ERC20 ABI for fetching name, symbol, and decimals
        const tokenAbi = [
            {
                "inputs": [],
                "name": "name",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "symbol",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    {
                        "internalType": "uint8",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        function getWeb3(useMetaMask = false) {
            if (useMetaMask && window.ethereum) {
                logMessage("Using MetaMask as Web3 provider");
                return new Web3(window.ethereum);
            }
            const provider = new Web3.providers.HttpProvider(RPC_ENDPOINTS[currentRpcIndex], { timeout: 5000 });
            logMessage(`Using RPC endpoint: ${RPC_ENDPOINTS[currentRpcIndex]}`);
            return new Web3(provider);
        }

        let web3 = getWeb3();
        let userAccount = null;
        let signer = null;
        let selectedWallet = null;
        let wallets = [];

        async function switchRpc() {
            currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
            web3 = getWeb3();
            logMessage(`Switched to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
        }

        async function checkNetwork() {
            try {
                await web3.eth.net.isListening();
                logMessage(`RPC endpoint ${RPC_ENDPOINTS[currentRpcIndex]} is listening`);
                const chainId = await web3.eth.getChainId();
                if (chainId !== 1) {
                    throw new Error(`Incorrect network! Expected Ethereum Mainnet (chainId 1), got chainId ${chainId}.`);
                }
                logMessage(`Connected to Ethereum Mainnet (chainId 1)`);
            } catch (error) {
                logMessage(`Network check failed: ${error.message}. Switching RPC...`);
                await switchRpc();
                throw error;
            }
        }

        async function withRetry(fn, maxRetries = 4, delayMs = 2000) {
            let lastError = null;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await checkNetwork();
                    return await fn();
                } catch (error) {
                    lastError = error;
                    logMessage(`Attempt ${attempt}/${maxRetries} with RPC ${RPC_ENDPOINTS[currentRpcIndex]} failed: ${error.message || 'Unknown error'}`);
                    if (attempt < maxRetries) {
                        await switchRpc();
                        await new Promise(resolve => setTimeout(resolve, delayMs * Math.pow(2, attempt - 1)));
                    }
                }
            }
            if (window.ethereum && selectedWallet && selectedWallet.isMetaMask) {
                try {
                    logMessage(`Falling back to MetaMask provider after ${maxRetries} failed attempts`);
                    web3 = getWeb3(true);
                    await checkNetwork();
                    return await fn();
                } catch (error) {
                    lastError = error;
                    logMessage(`MetaMask fallback failed: ${error.message || 'Unknown error'}`);
                }
            }
            const errorMessage = `Operation failed after ${maxRetries} attempts${window.ethereum ? ' and MetaMask fallback' : ''}: ${lastError.message || 'Unknown error'}`;
            logMessage(errorMessage);
            throw new Error(errorMessage);
        }

        function logMessage(message) {
            console.log(message);
            const logDiv = document.getElementById('log');
            const entry = document.createElement('p');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    logMessage("Please install MetaMask to use this feature.");
                    document.getElementById("create-error").innerText = "Please install MetaMask to use this feature.";
                    document.getElementById("create-error").className = "error-message";
                    return;
                }
                logMessage("Requesting MetaMask accounts...");
                web3 = getWeb3(true);
                const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
                if (!accounts || accounts.length === 0) {
                    throw new Error("No accounts returned by MetaMask");
                }
                userAccount = accounts[0];
                logMessage(`MetaMask account fetched: ${userAccount}`);
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                document.getElementById("walletAddress").innerText = `Wallet Address: ${userAccount}`;
                document.getElementById("create-status").innerText = "Wallet connected successfully!";
                document.getElementById("create-status").className = "status-message";
                await initializeWallets();
                await refreshDAOs();
            } catch (error) {
                logMessage(`Wallet connection error: ${error.message}`);
                document.getElementById("create-error").innerText = `Failed to connect wallet: ${error.message}`;
                document.getElementById("create-error").className = "error-message";
            }
        }

        async function initializeWallets() {
            try {
                logMessage("Initializing wallets...");
                wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
                if (window.ethereum && userAccount) {
                    const metamaskWallet = { address: userAccount, type: 'MetaMask', isMetaMask: true };
                    if (!wallets.some(w => w.address.toLowerCase() === metamaskWallet.address.toLowerCase() && w.type === 'MetaMask')) {
                        wallets = wallets.filter(w => w.type !== 'MetaMask');
                        wallets.push(metamaskWallet);
                    }
                }
                wallets = wallets.map(wallet => {
                    if (wallet.type === 'MoneyFund' && wallet.privateKey) {
                        return { ...wallet, isMetaMask: false };
                    }
                    return wallet;
                });
                localStorage.setItem('wallets', JSON.stringify(wallets));
                const walletSelector = document.getElementById('wallet-selector');
                walletSelector.innerHTML = '<option value="">-- Select Wallet --</option>';
                wallets.forEach((wallet, index) => {
                    if (wallet.address) {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${wallet.type}: ${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
                        walletSelector.appendChild(option);
                    } else {
                        logMessage(`Invalid wallet at index ${index}: missing address`);
                    }
                });
                const selectedIndex = parseInt(localStorage.getItem('selectedWalletIndex'));
                logMessage(`Stored selectedWalletIndex: ${selectedIndex}`);
                if (wallets.length > 0 && !isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < wallets.length) {
                    selectedWallet = wallets[selectedIndex];
                    userAccount = selectedWallet.address;
                    walletSelector.value = selectedIndex;
                    document.getElementById("walletAddress").innerText = `Wallet Address: ${userAccount}`;
                    if (selectedWallet.isMetaMask && window.ethereum) {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (!accounts || accounts.length === 0 || accounts[0].toLowerCase() !== selectedWallet.address.toLowerCase()) {
                            logMessage("MetaMask selected but not connected. Requesting connection.");
                            await connectWallet();
                        } else {
                            signer = new ethers.providers.Web3Provider(window.ethereum).getSigner();
                            logMessage("MetaMask wallet synced");
                        }
                    } else {
                        web3 = getWeb3();
                        signer = null;
                        logMessage("MoneyFund wallet selected");
                    }
                    logMessage(`Selected wallet: ${userAccount}`);
                    await refreshDAOs();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    walletSelector.value = "";
                    document.getElementById("walletAddress").innerText = "Wallet Address: Not connected";
                    logMessage("No valid wallet selected");
                }
            } catch (error) {
                logMessage(`Wallet initialization error: ${error.message}`);
                document.getElementById("walletAddress").innerText = "Wallet Address: Error loading wallets";
            }
        }

        function selectWallet(index) {
            try {
                const idx = parseInt(index);
                document.getElementById("create-status").innerText = "";
                document.getElementById("create-error").innerText = "";
                if (idx >= 0 && idx < wallets.length && wallets[idx].address) {
                    selectedWallet = wallets[idx];
                    localStorage.setItem('selectedWalletIndex', idx);
                    userAccount = selectedWallet.address;
                    document.getElementById("walletAddress").innerText = `Wallet Address: ${userAccount}`;
                    if (selectedWallet.isMetaMask) {
                        if (window.ethereum) {
                            web3 = getWeb3(true);
                            const accounts = window.ethereum.request({ method: 'eth_accounts' });
                            if (!accounts || accounts.length === 0) {
                                logMessage("MetaMask not connected. Triggering connect.");
                                connectWallet();
                            } else {
                                signer = new ethers.providers.Web3Provider(window.ethereum).getSigner();
                                logMessage("MetaMask wallet selected and synced");
                            }
                        } else {
                            logMessage("MetaMask extension not detected.");
                            document.getElementById("create-error").innerText = "MetaMask extension not detected.";
                            document.getElementById("create-error").className = "error-message";
                            selectedWallet = null;
                            userAccount = null;
                            document.getElementById("walletAddress").innerText = "Wallet Address: Not connected";
                            document.getElementById('wallet-selector').value = "";
                            localStorage.removeItem('selectedWalletIndex');
                        }
                    } else {
                        web3 = getWeb3();
                        signer = null;
                        logMessage("MoneyFund wallet selected");
                    }
                    logMessage(`Selected wallet: ${userAccount}`);
                    refreshDAOs();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    localStorage.removeItem('selectedWalletIndex');
                    document.getElementById("walletAddress").innerText = "Wallet Address: Not connected";
                    document.getElementById('wallet-selector').value = "";
                    web3 = getWeb3();
                    logMessage("Invalid wallet selection");
                }
            } catch (error) {
                logMessage(`Wallet selection error: ${error.message}`);
                document.getElementById("create-error").innerText = `Failed to select wallet: ${error.message}`;
                document.getElementById("create-error").className = "error-message";
            }
        }

        async function getGasPrice() {
            return await withRetry(async () => {
                const baseGasPrice = BigInt(await web3.eth.getGasPrice());
                const baseGasPriceGwei = Number(web3.utils.fromWei(baseGasPrice.toString(), 'gwei'));
                const adjustedGasPriceGwei = Math.max(1, baseGasPriceGwei * 1.25);
                return web3.utils.toWei(adjustedGasPriceGwei.toFixed(0), 'gwei');
            });
        }

        async function createDAO() {
            try {
                logMessage(`Signer: ${signer ? 'OK' : 'NULL'}, Web3: ${!!web3}, Account: ${userAccount}`);
                logMessage("createDAO function triggered");
                const status = document.getElementById("create-status");
                const error = document.getElementById("create-error");
                status.innerText = "Initiating DAO creation...";
                status.className = "status-message";
                error.innerText = "";
                error.className = "error-message";

                if (!selectedWallet || !userAccount) {
                    logMessage("No wallet selected or connected");
                    error.innerText = "Please connect and select a wallet first.";
                    status.innerText = "";
                    return;
                }
                logMessage(`Wallet connected: ${userAccount}`);

                const tokenAddress = document.getElementById("token-address").value.trim();
                const votingPeriodDays = document.getElementById("voting-period").value.trim();
                const countNonRespondersAsYes = document.getElementById("count-non-responders").value === "true";

                logMessage(`Inputs: token=${tokenAddress}, votingPeriod=${votingPeriodDays} days, countNonRespondersAsYes=${countNonRespondersAsYes}`);

                if (!tokenAddress || !votingPeriodDays) {
                    logMessage("Missing input fields");
                    error.innerText = "Please fill in all fields.";
                    status.innerText = "";
                    return;
                }

                if (!web3.utils.isAddress(tokenAddress)) {
                    logMessage(`Invalid token address: ${tokenAddress}`);
                    error.innerText = `Invalid token address: ${tokenAddress}`;
                    status.innerText = "";
                    return;
                }

                const votingPeriodNum = parseInt(votingPeriodDays);
                if (isNaN(votingPeriodNum) || votingPeriodNum <= 0) {
                    logMessage("Invalid voting period");
                    error.innerText = "Voting period must be a positive number of days.";
                    status.innerText = "";
                    return;
                }

                const votingPeriodSeconds = votingPeriodNum * 24 * 60 * 60;

                status.innerText = "Preparing to deploy DAO...";
                logMessage("Creating factory contract instance");
                const factory = new web3.eth.Contract(daoFactoryAbi, FACTORY_ADDRESS);

                let gasEstimate;
                try {
                    logMessage("Estimating gas");
                    gasEstimate = await withRetry(() =>
                        factory.methods.createDAO(tokenAddress, votingPeriodSeconds, countNonRespondersAsYes).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    logMessage(`Estimated gas limit: ${gasEstimate}`);
                } catch (err) {
                    gasEstimate = 1000000;
                    logMessage(`Gas estimation failed, using default ${gasEstimate}: ${err.message}`);
                }

                const gasPrice = await getGasPrice();
                logMessage(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                status.innerText = selectedWallet.isMetaMask ? "Deploying DAO... Please confirm in MetaMask." : "Deploying DAO... Signing with MoneyFund wallet.";
                logMessage("Initiating transaction");

                let tx;
                let daoAddress;
                if (selectedWallet.isMetaMask) {
                    logMessage("Using MetaMask for transaction");
                    if (!signer && window.ethereum) {
                        const provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = provider.getSigner();
                        logMessage("Initialized signer from MetaMask provider");
                    }
                    if (!signer) {
                        throw new Error("MetaMask signer not available");
                    }
                    const factoryEthers = new ethers.Contract(FACTORY_ADDRESS, daoFactoryAbi, signer);
                    tx = await factoryEthers.createDAO(tokenAddress, votingPeriodSeconds, countNonRespondersAsYes, {
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    logMessage("Waiting for transaction confirmation");
                    const receipt = await tx.wait();
                    if (receipt.status !== 1) {
                        throw new Error(`Transaction failed with status ${receipt.status}. Tx: ${receipt.transactionHash}`);
                    }
                    logMessage(`Transaction confirmed. Tx: ${receipt.transactionHash}, Logs: ${receipt.logs.length}`);
                    const iface = new ethers.utils.Interface(daoFactoryAbi);
                    const daoCreatedLog = receipt.logs.find(log => {
                        try {
                            const parsedLog = iface.parseLog(log);
                            return parsedLog.name === 'DAOCreated';
                        } catch (e) {
                            logMessage(`Failed to parse log: ${e.message}`);
                            return false;
                        }
                    });
                    if (!daoCreatedLog) {
                        throw new Error(`DAOCreated event not found in transaction logs. Tx: ${receipt.transactionHash}, Logs: ${JSON.stringify(receipt.logs)}`);
                    }
                    daoAddress = daoCreatedLog.args[0]; // DAOCreated event's first argument is daoAddress
                } else {
                    logMessage("Using MoneyFund wallet for transaction");
                    if (!selectedWallet.privateKey) {
                        throw new Error("No private key available for MoneyFund wallet");
                    }
                    const account = web3.eth.accounts.privateKeyToAccount(selectedWallet.privateKey);
                    if (account.address.toLowerCase() !== userAccount.toLowerCase()) {
                        throw new Error("Private key does not match selected wallet address");
                    }
                    const txData = factory.methods.createDAO(tokenAddress, votingPeriodSeconds, countNonRespondersAsYes).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: FACTORY_ADDRESS,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                    logMessage(`Transaction confirmed. Tx: ${tx.transactionHash}, Logs: ${tx.logs.length}`);
                    if (!tx.status) {
                        throw new Error(`Transaction failed with status ${tx.status}. Tx: ${tx.transactionHash}`);
                    }
                    const iface = new ethers.utils.Interface(daoFactoryAbi);
                    const daoCreatedLog = tx.logs.find(log => {
                        try {
                            const parsedLog = iface.parseLog(log);
                            return parsedLog.name === 'DAOCreated';
                        } catch (e) {
                            logMessage(`Failed to parse log: ${e.message}`);
                            return false;
                        }
                    });
                    if (!daoCreatedLog) {
                        throw new Error(`DAOCreated event not found in transaction logs. Tx: ${tx.transactionHash}, Logs: ${JSON.stringify(tx.logs)}`);
                    }
                    daoAddress = daoCreatedLog.args[0]; // DAOCreated event's first argument is daoAddress
                }

                if (!web3.utils.isAddress(daoAddress)) {
                    throw new Error(`Invalid DAO address received: ${daoAddress}. Tx: ${tx.transactionHash}`);
                }

                const tokenContract = new web3.eth.Contract(tokenAbi, tokenAddress);
                let tokenName = "Unknown";
                let tokenSymbol = "UNK";
                try {
                    tokenName = await withRetry(() => tokenContract.methods.name().call());
                    tokenSymbol = await withRetry(() => tokenContract.methods.symbol().call());
                } catch (error) {
                    logMessage(`Failed to fetch token name/symbol for ${tokenAddress}: ${error.message}`);
                }

                status.innerText = `DAO for ${tokenName} (${tokenSymbol}) deployed at: ${daoAddress}! Tx: ${tx.transactionHash || tx.hash}`;
                logMessage(`DAO for ${tokenName} (${tokenSymbol}) deployed at: ${daoAddress}: ${tx.transactionHash || tx.hash}`);
                await refreshDAOs();
            } catch (err) {
                logMessage(`DAO creation failed: ${err.message}`);
                document.getElementById("create-error").innerText = `DAO creation failed: ${err.message}. Check transaction logs or verify contract at ${FACTORY_ADDRESS}.`;
                document.getElementById("create-error").className = "error-message";
                document.getElementById("create-status").innerText = "";
                alert(`Failed to create DAO: ${err.message}. Check the console and log for details.`);
            }
        }

        async function createProposal(daoAddress) {
            try {
                logMessage(`Creating proposal for DAO: ${daoAddress}`);
                const status = document.getElementById("dao-status");
                status.innerText = "Initiating proposal creation...";
                status.className = "status-message";

                if (!selectedWallet || !userAccount) {
                    logMessage("No wallet selected or connected");
                    status.innerText = "Please connect and select a wallet first.";
                    status.className = "error-message";
                    return;
                }

                const description = document.getElementById(`proposal-description-${daoAddress}`).value.trim();
                const proposalType = parseInt(document.getElementById(`proposal-type-${daoAddress}`).value);
                const destination = document.getElementById(`proposal-destination-${daoAddress}`).value.trim();
                const amount = document.getElementById(`proposal-amount-${daoAddress}`).value.trim();
                const tokenAddress = document.getElementById(`proposal-token-address-${daoAddress}`).value.trim();

                logMessage(`Proposal inputs: description=${description}, type=${proposalType}, destination=${destination}, amount=${amount}, tokenAddress=${tokenAddress}`);

                if (!description || isNaN(proposalType) || !amount || !tokenAddress) {
                    logMessage("Missing proposal fields");
                    status.innerText = "Please fill in all required proposal fields.";
                    status.className = "error-message";
                    return;
                }

                if ((proposalType === 2 || proposalType === 3) && (!destination || !web3.utils.isAddress(destination))) {
                    logMessage("Invalid destination address for withdraw proposal");
                    status.innerText = "Invalid destination address for withdraw proposal.";
                    status.className = "error-message";
                    return;
                }

                if (!web3.utils.isAddress(tokenAddress)) {
                    logMessage("Invalid token address");
                    status.innerText = "Invalid token address.";
                    status.className = "error-message";
                    return;
                }

                const amountWei = web3.utils.toWei(amount, 'ether'); // Assuming 18 decimals
                if (isNaN(amountWei) || Number(amountWei) <= 0) {
                    logMessage("Invalid proposal amount");
                    status.innerText = "Amount must be a positive number.";
                    status.className = "error-message";
                    return;
                }

                if (proposalType < 0 || proposalType > 3) {
                    logMessage("Invalid proposal type");
                    status.innerText = "Invalid proposal type.";
                    status.className = "error-message";
                    return;
                }

                const daoContract = new web3.eth.Contract(daoAbi, daoAddress);
                let gasEstimate;
                try {
                    logMessage("Estimating gas for proposal creation");
                    gasEstimate = await withRetry(() =>
                        daoContract.methods.createProposal(description, proposalType, destination || "0x0000000000000000000000000000000000000000", amountWei, tokenAddress).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    logMessage(`Estimated gas limit: ${gasEstimate}`);
                } catch (err) {
                    gasEstimate = 500000;
                    logMessage(`Gas estimation failed, using default ${gasEstimate}: ${err.message}`);
                }

                const gasPrice = await getGasPrice();
                logMessage(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                status.innerText = selectedWallet.isMetaMask ? "Creating proposal... Please confirm in MetaMask." : "Creating proposal... Signing with MoneyFund wallet.";
                logMessage("Initiating proposal transaction");

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer && window.ethereum) {
                        const provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = provider.getSigner();
                        logMessage("Initialized signer from MetaMask provider");
                    }
                    if (!signer) {
                        throw new Error("MetaMask signer not available");
                    }
                    const daoEthers = new ethers.Contract(daoAddress, daoAbi, signer);
                    tx = await daoEthers.createProposal(description, proposalType, destination || "0x0000000000000000000000000000000000000000", amountWei, tokenAddress, {
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    logMessage("Waiting for proposal transaction confirmation");
                    const receipt = await tx.wait();
                    if (receipt.status !== 1) {
                        throw new Error(`Proposal transaction failed with status ${receipt.status}. Tx: ${receipt.transactionHash}`);
                    }
                    logMessage(`Proposal transaction confirmed. Tx: ${receipt.transactionHash}`);
                } else {
                    logMessage("Using MoneyFund wallet for proposal transaction");
                    if (!selectedWallet.privateKey) {
                        throw new Error("No private key available for MoneyFund wallet");
                    }
                    const account = web3.eth.accounts.privateKeyToAccount(selectedWallet.privateKey);
                    if (account.address.toLowerCase() !== userAccount.toLowerCase()) {
                        throw new Error("Private key does not match selected wallet address");
                    }
                    const txData = daoContract.methods.createProposal(description, proposalType, destination || "0x0000000000000000000000000000000000000000", amountWei, tokenAddress).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: daoAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                    logMessage(`Proposal transaction confirmed. Tx: ${tx.transactionHash}`);
                    if (!tx.status) {
                        throw new Error(`Proposal transaction failed with status ${tx.status}. Tx: ${tx.transactionHash}`);
                    }
                }

                status.innerText = `Proposal created successfully for DAO: ${daoAddress}! Tx: ${tx.transactionHash || tx.hash}`;
                logMessage(`Proposal created: ${description} for DAO: ${daoAddress}, Tx: ${tx.transactionHash || tx.hash}`);
                await refreshDAOs();
            } catch (err) {
                logMessage(`Proposal creation failed: ${err.message}`);
                status.innerText = `Proposal creation failed: ${err.message}. Check transaction logs.`;
                status.className = "error-message";
                alert(`Failed to create proposal: ${err.message}. Check the console and log for details.`);
            }
        }

        async function voteOnProposal(daoAddress) {
            try {
                logMessage(`Voting on proposal for DAO: ${daoAddress}`);
                const status = document.getElementById("dao-status");
                status.innerText = "Initiating vote...";
                status.className = "status-message";

                if (!selectedWallet || !userAccount) {
                    logMessage("No wallet selected or connected");
                    status.innerText = "Please connect and select a wallet first.";
                    status.className = "error-message";
                    return;
                }

                const proposalId = document.getElementById(`vote-proposal-id-${daoAddress}`).value.trim();
                const support = document.getElementById(`vote-support-${daoAddress}`).value === "true";

                logMessage(`Vote inputs: proposalId=${proposalId}, support=${support}`);

                if (!proposalId) {
                    logMessage("Missing proposal ID");
                    status.innerText = "Please enter a proposal ID.";
                    status.className = "error-message";
                    return;
                }

                const proposalIdNum = parseInt(proposalId);
                if (isNaN(proposalIdNum) || proposalIdNum < 0) {
                    logMessage("Invalid proposal ID");
                    status.innerText = "Proposal ID must be a non-negative number.";
                    status.className = "error-message";
                    return;
                }

                const daoContract = new web3.eth.Contract(daoAbi, daoAddress);
                let gasEstimate;
                try {
                    logMessage("Estimating gas for vote");
                    gasEstimate = await withRetry(() =>
                        daoContract.methods.vote(proposalIdNum, support).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    logMessage(`Estimated gas limit: ${gasEstimate}`);
                } catch (err) {
                    gasEstimate = 200000;
                    logMessage(`Gas estimation failed, using default ${gasEstimate}: ${err.message}`);
                }

                const gasPrice = await getGasPrice();
                logMessage(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                status.innerText = selectedWallet.isMetaMask ? "Voting... Please confirm in MetaMask." : "Voting... Signing with MoneyFund wallet.";
                logMessage("Initiating vote transaction");

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer && window.ethereum) {
                        const provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = provider.getSigner();
                        logMessage("Initialized signer from MetaMask provider");
                    }
                    if (!signer) {
                        throw new Error("MetaMask signer not available");
                    }
                    const daoEthers = new ethers.Contract(daoAddress, daoAbi, signer);
                    tx = await daoEthers.vote(proposalIdNum, support, {
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    logMessage("Waiting for vote transaction confirmation");
                    const receipt = await tx.wait();
                    if (receipt.status !== 1) {
                        throw new Error(`Vote transaction failed with status ${receipt.status}. Tx: ${receipt.transactionHash}`);
                    }
                    logMessage(`Vote transaction confirmed. Tx: ${receipt.transactionHash}`);
                } else {
                    logMessage("Using MoneyFund wallet for vote transaction");
                    if (!selectedWallet.privateKey) {
                        throw new Error("No private key available for MoneyFund wallet");
                    }
                    const account = web3.eth.accounts.privateKeyToAccount(selectedWallet.privateKey);
                    if (account.address.toLowerCase() !== userAccount.toLowerCase()) {
                        throw new Error("Private key does not match selected wallet address");
                    }
                    const txData = daoContract.methods.vote(proposalIdNum, support).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: daoAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                    logMessage(`Vote transaction confirmed. Tx: ${tx.transactionHash}`);
                    if (!tx.status) {
                        throw new Error(`Vote transaction failed with status ${tx.status}. Tx: ${tx.transactionHash}`);
                    }
                }

                status.innerText = `Voted ${support ? 'Yes' : 'No'} on proposal ${proposalId} for DAO: ${daoAddress}! Tx: ${tx.transactionHash || tx.hash}`;
                logMessage(`Voted ${support ? 'Yes' : 'No'} on proposal ${proposalId} for DAO: ${daoAddress}, Tx: ${tx.transactionHash || tx.hash}`);
                await refreshDAOs();
            } catch (err) {
                logMessage(`Vote failed: ${err.message}`);
                status.innerText = `Vote failed: ${err.message}. Check transaction logs.`;
                status.className = "error-message";
                alert(`Failed to vote: ${err.message}. Check the console and log for details.`);
            }
        }

        async function refreshDAOs() {
            const statusMessage = document.getElementById("dao-status");
            statusMessage.innerText = "Loading DAOs...";
            statusMessage.className = "status-message";

            // Check if a wallet is selected
            if (!selectedWallet || !userAccount) {
                logMessage("No wallet selected, skipping DAO refresh.");
                statusMessage.innerText = "Please select a wallet to view DAOs.";
                statusMessage.className = "error-message";
                document.getElementById("dao-card-container").innerHTML = '<p style="text-align: center; color: #E5E7EB;">Please select a wallet to view DAOs.</p>';
                return;
            }

            try {
                const factory = new web3.eth.Contract(daoFactoryAbi, FACTORY_ADDRESS);
                const cardContainer = document.getElementById("dao-card-container");
                cardContainer.innerHTML = "";

                // Fetch all DAO addresses using getAllDAOs
                const daoAddresses = await withRetry(() => factory.methods.getAllDAOs().call());
                if (daoAddresses.length === 0) {
                    cardContainer.innerHTML = '<p style="text-align: center; color: #E5E7EB;">No DAOs found. Deploy one to get started.</p>';
                    statusMessage.innerText = "No DAOs available.";
                    statusMessage.className = "status-message";
                    return;
                }

                const daos = [];
                for (const daoAddress of daoAddresses) {
                    try {
                        if (daoAddress === "0x0000000000000000000000000000000000000000") {
                            logMessage(`Skipping invalid DAO address: ${daoAddress}`);
                            continue;
                        }
                        const daoContract = new web3.eth.Contract(daoAbi, daoAddress);
                        const daoInfo = await withRetry(() => daoContract.methods.getDAOInfo().call());
                        const countNonRespondersAsYes = await withRetry(() => daoContract.methods.countNonRespondersAsYes().call());
                        const votingPeriod = await withRetry(() => daoContract.methods.votingPeriod().call());
                        const tokenAddress = daoInfo.tokenAddress;
                        const tokenContract = new web3.eth.Contract(tokenAbi, tokenAddress);
                        let tokenName = "Unknown";
                        let tokenSymbol = "UNK";
                        let decimals = 18; // Default to 18 if decimals call fails
                        try {
                            tokenName = await withRetry(() => tokenContract.methods.name().call());
                            tokenSymbol = await withRetry(() => tokenContract.methods.symbol().call());
                            decimals = await withRetry(() => tokenContract.methods.decimals().call());
                        } catch (error) {
                            logMessage(`Failed to fetch token name/symbol/decimals for ${tokenAddress}: ${error.message}`);
                        }
                        daos.push({ daoAddress, token: tokenAddress, tokenName, tokenSymbol, daoInfo, countNonRespondersAsYes, votingPeriod, decimals });
                    } catch (error) {
                        logMessage(`Failed to fetch DAO info for ${daoAddress}: ${error.message}`);
                    }
                }

                if (daos.length === 0) {
                    cardContainer.innerHTML = '<p style="text-align: center; color: #E5E7EB;">No valid DAOs found.</p>';
                    statusMessage.innerText = "No DAOs available.";
                    statusMessage.className = "status-message";
                    return;
                }

                for (const dao of daos) {
                    const { daoAddress, token, tokenName, tokenSymbol, daoInfo, countNonRespondersAsYes, votingPeriod, decimals } = dao;
                    const ethBalance = web3.utils.fromWei(daoInfo.ethBalance, 'ether');
                    const tokenBalance = daoInfo.tokenBalance ? web3.utils.fromWei(daoInfo.tokenBalance, 'ether') : '0';
                    const formattedTotalSupply = (Number(daoInfo.totalSupply) / (10 ** decimals)).toFixed(4);
                    const votingPeriodDays = (Number(votingPeriod) / (24 * 60 * 60)).toFixed(2);
                    const lastProposalTime = daoInfo.lastProposalTime > 0 ? new Date(Number(daoInfo.lastProposalTime) * 1000).toLocaleDateString() : "None";

                    // Format proposals
                    let proposalsHtml = '<div class="proposals-list"><h3>Proposals</h3>';
                    if (daoInfo.proposals.length === 0) {
                        proposalsHtml += '<p>No proposals found.</p>';
                    } else {
                        for (const proposal of daoInfo.proposals) {
                            const proposalTypeStr = ['Swap ETH to ERC20', 'Swap ERC20 to ETH', 'Withdraw ETH', 'Withdraw ERC20'][proposal.proposalType] || 'Unknown';
                            const status = proposal.executed ? (proposal.yesVotes > (Number(daoInfo.totalSupply) / 2) ? 'Passed' : 'Failed') : 'Active';
                            proposalsHtml += `
                                <div class="proposal-item">
                                    <label>ID: ${proposal.id}</label>
                                    <span>Description: ${proposal.description}</span>
                                    <span>Type: ${proposalTypeStr}</span>
                                    <span>Destination: ${proposal.destination.slice(0, 6)}...${proposal.destination.slice(-4)}</span>
                                    <span>Amount: ${web3.utils.fromWei(proposal.amount, 'ether')}</span>
                                    <span>Token: ${proposal.tokenAddress.slice(0, 6)}...${proposal.tokenAddress.slice(-4)}</span>
                                    <span>Yes Votes: ${web3.utils.fromWei(proposal.yesVotes, 'ether')}</span>
                                    <span>Start Time: ${new Date(Number(proposal.startTime) * 1000).toLocaleString()}</span>
                                    <span>Status: ${status}</span>
                                </div>
                            `;
                        }
                    }
                    proposalsHtml += '</div>';

                    const card = document.createElement("div");
                    card.className = "dao-card";
                    card.innerHTML = `
                        <div class="dao-card-header">
                            <h3>${tokenName}</h3>
                            <span>${tokenSymbol}</span>
                        </div>
                        <div class="dao-card-details">
                            <div>
                                <label>DAO Address</label>
                                <span>${daoAddress.slice(0, 6)}...${daoAddress.slice(-4)}</span>
                            </div>
                            <div>
                                <label>Token Address</label>
                                <span>${token.slice(0, 6)}...${token.slice(-4)}</span>
                            </div>
                            <div>
                                <label>Total Supply</label>
                                <span>${formattedTotalSupply}</span>
                            </div>
                            <div>
                                <label>ETH Balance</label>
                                <span>${Number(ethBalance).toFixed(4)} ETH</span>
                            </div>
                            <div>
                                <label>Token Balance</label>
                                <span>${Number(tokenBalance).toFixed(4)}</span>
                            </div>
                            <div>
                                <label>Voting Period</label>
                                <span>${votingPeriodDays} days</span>
                            </div>
                            <div>
                                <label>Non-Responders Vote Yes</label>
                                <span>${countNonRespondersAsYes ? "Yes" : "No"}</span>
                            </div>
                                                       <div>
                                <label>Proposal Count</label>
                                <span>${daoInfo.proposalCount}</span>
                            </div>
                            <div>
                                <label>Active Proposals</label>
                                <span>${daoInfo.activeProposals}</span>
                            </div>
                            <div>
                                <label>Proposals Per Day</label>
                                <span>${daoInfo.proposalCountPerDay}</span>
                            </div>
                            <div>
                                <label>Last Proposal</label>
                                <span>${lastProposalTime}</span>
                            </div>
                        </div>
                        <div class="dao-actions">
                            <button onclick="document.getElementById('proposal-form-${daoAddress}').style.display='block';">Create Proposal</button>
                            <button onclick="document.getElementById('vote-form-${daoAddress}').style.display='block';">Vote</button>
                        </div>
                        <div class="proposal-form" id="proposal-form-${daoAddress}" style="display: none;">
                            <label for="proposal-description-${daoAddress}">Description:</label>
                            <input id="proposal-description-${daoAddress}" type="text" placeholder="e.g., Swap ETH for tokens" />
                            <label for="proposal-type-${daoAddress}">Proposal Type:</label>
                            <select id="proposal-type-${daoAddress}" onchange="toggleDestinationField('${daoAddress}')">
                                <option value="0">Swap ETH to ERC20</option>
                                <option value="1">Swap ERC20 to ETH</option>
                                <option value="2">Withdraw ETH</option>
                                <option value="3">Withdraw ERC20</option>
                            </select>
                            <label id="proposal-destination-label-${daoAddress}" for="proposal-destination-${daoAddress}" style="display: none;">Destination Address:</label>
                            <input id="proposal-destination-${daoAddress}" type="text" placeholder="e.g., 0xDestination" style="display: none;" />
                            <label for="proposal-amount-${daoAddress}">Amount (in tokens or ETH):</label>
                            <input id="proposal-amount-${daoAddress}" type="number" placeholder="e.g., 1" step="0.0001" />
                            <label for="proposal-token-address-${daoAddress}">Token Address:</label>
                            <input id="proposal-token-address-${daoAddress}" type="text" placeholder="e.g., 0xToken" />
                            <button onclick="createProposal('${daoAddress}')">Submit Proposal</button>
                        </div>
                        <div class="vote-form" id="vote-form-${daoAddress}" style="display: none;">
                            <label for="vote-proposal-id-${daoAddress}">Proposal ID:</label>
                            <input id="vote-proposal-id-${daoAddress}" type="number" placeholder="e.g., 0" min="0" step="1" />
                            <label for="vote-support-${daoAddress}">Vote:</label>
                            <select id="vote-support-${daoAddress}">
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                            <button onclick="voteOnProposal('${daoAddress}')">Submit Vote</button>
                        </div>
                        ${proposalsHtml}
                    `;
                    cardContainer.appendChild(card);

                    // Add event listener for proposal type change after card is added to DOM
                    setTimeout(() => {
                        const selectElement = document.getElementById(`proposal-type-${daoAddress}`);
                        if (selectElement) {
                            selectElement.addEventListener('change', () => toggleDestinationField(daoAddress));
                            // Initialize destination field visibility
                            toggleDestinationField(daoAddress);
                        }
                    }, 0);
                }

                statusMessage.innerText = `Loaded ${daos.length} DAOs successfully!`;
                statusMessage.className = "status-message";
            } catch (error) {
                console.log("Refresh DAOs error details:", error);
                logMessage(`Failed to load DAOs: ${error.message}`);
                statusMessage.innerText = `Failed to load DAOs: ${error.message}. Ensure contract is accessible at ${FACTORY_ADDRESS}.`;
                statusMessage.className = "error-message";
            }
        }

        function toggleDestinationField(daoAddress) {
            const proposalType = parseInt(document.getElementById(`proposal-type-${daoAddress}`).value);
            const destinationLabel = document.getElementById(`proposal-destination-label-${daoAddress}`);
            const destinationInput = document.getElementById(`proposal-destination-${daoAddress}`);
            // Show destination field only for Withdraw ETH (2) and Withdraw ERC20 (3)
            const shouldShow = proposalType === 2 || proposalType === 3;
            destinationLabel.style.display = shouldShow ? 'block' : 'none';
            destinationInput.style.display = shouldShow ? 'block' : 'none';
        }

        window.addEventListener('load', async () => {
            await initializeWallets();
            const launchButton = document.getElementById('launch-dao-button');
            launchButton.addEventListener('click', () => {
                logMessage("Deploy DAO button clicked");
                createDAO();
            });
        });

        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async (accounts) => {
                if (accounts.length === 0) {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    document.getElementById("walletAddress").innerText = "Wallet Address: Not connected";
                    document.getElementById('wallet-selector').value = "";
                    localStorage.removeItem('selectedWalletIndex');
                    logMessage("MetaMask disconnected.");
                } else if (selectedWallet && selectedWallet.isMetaMask && accounts[0].toLowerCase() !== selectedWallet.address.toLowerCase()) {
                    logMessage("MetaMask account changed. Reconnecting...");
                    await connectWallet();
                }
            });

            window.ethereum.on('chainChanged', () => {
                logMessage("Network changed. Reloading...");
                window.location.reload();
            });
        }
    </script>
</body>
</html>
