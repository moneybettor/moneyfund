<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoneyFund Dividend Pool Launchpad</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #F9FAFB;
            min-height: 100vh;
            line-height: 1.6;
            background: linear-gradient(135deg, #0B0F24, #1A1E3B);
            padding: 24px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" opacity="0.05"%3E%3Cdefs%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3C/defs%3E%3Crect width="100%" height="100%" filter="url(%23noise)"/%3E%3C/svg%3E');
            z-index: -1;
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .full-width-container {
            flex: 1;
            min-width: 320px;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            margin-bottom: 24px;
            transition: transform 0.3s ease;
        }

        .full-width-container:hover {
            transform: translateY(-4px);
        }

        .launch-pool-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .bottom-bar {
            position: sticky;
            bottom: 16px;
            max-width: 1280px;
            margin: 24px auto;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .bottom-bar-content {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: nowrap;
            justify-content: space-between;
        }

        #status-log {
            max-height: 100px;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.85rem;
            background: rgba(17, 24, 39, 0.8);
            color: #D1D5DB;
            border-radius: 8px;
            width: 100%;
            max-width: 400px;
            scrollbar-width: thin;
            scrollbar-color: #A5B4FC rgba(30, 41, 59, 0.5);
        }

        #status-log::-webkit-scrollbar {
            width: 4px;
        }

        #status-log::-webkit-scrollbar-thumb {
            background: #A5B4FC;
            border-radius: 2px;
        }

        #status-log::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        .status-entry {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid rgba(165, 180, 252, 0.1);
            animation: fadeIn 0.3s ease-out;
            font-size: 0.85rem;
        }

        .status-entry.success {
            color: #34D399;
        }

        .status-entry.pending {
            color: #F9FAFB;
            background: rgba(255, 255, 255, 0.05);
        }

        .status-entry.error {
            color: #F87171;
        }

        .status-timestamp {
            color: #9CA3AF;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        button {
            padding: 10px 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #4F46E5, #7C3AED);
            color: #F9FAFB;
            font-weight: 600;
            font-size: 0.95rem;
            transition: transform 0.2s, background 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
            min-height: 48px;
        }

        button:hover {
            background: linear-gradient(90deg, #4338CA, #6D28D9);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }

        button:active::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            transform: scale(1);
            transition: transform 0.2s;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #F9FAFB;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #connect-wallet-button, #launch-pool-button {
            padding: 12px 24px;
        }

        .stake-button, .unstake-button, .claim-rewards-button {
            padding: 8px 12px;
            font-size: 0.9rem;
        }

        .copy-button {
            background: #6B7280;
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        .copy-button:hover {
            background: #4B5563;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        input, select {
            padding: 10px;
            width: 100%;
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 8px;
            background: rgba(17, 24, 39, 0.8);
            color: #F9FAFB;
            font-size: 0.95rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: border 0.3s, box-shadow 0.3s;
        }

        input:focus, select:focus {
            border: 1px solid #A5B4FC;
            box-shadow: 0 0 8px rgba(165, 180, 252, 0.5);
            outline: none;
        }

        .stake-amount-input {
            width: 120px;
            margin-right: 8px;
        }

        input::placeholder {
            color: #9CA3AF;
            opacity: 0.7;
        }

        select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23F9FAFB%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 10px auto;
            padding-right: 32px;
            max-width: 200px;
        }

        h2 {
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #FFFFFF;
            text-align: center;
            margin-bottom: 16px;
        }

        h3 {
            font-size: 1.3rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #FFFFFF;
            margin: 12px 0 8px;
        }

        #walletAddress {
            font-size: 0.9rem;
            color: #D1D5DB;
            word-break: break-all;
            margin: 8px 0;
        }

        label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #D1D5DB;
            margin-bottom: 4px;
            display: block;
        }

        .field-container {
            position: relative;
            margin-bottom: 12px;
        }

        .label-with-help {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .help-icon {
            cursor: pointer;
            font-size: 0.8rem;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            border-radius: 50%;
            background: #6B7280;
            color: #F9FAFB;
            transition: background 0.3s;
        }

        .help-icon:hover {
            background: #4B5563;
        }

        .help-note {
            display: none;
            font-size: 0.8rem;
            color: #D1D5DB;
            background: rgba(17, 24, 39, 0.9);
            padding: 8px;
            border-radius: 6px;
            margin-top: 4px;
            border: 1px solid rgba(165, 180, 252, 0.2);
            max-width: 300px;
        }

        .help-note.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #pool-list {
            margin-top: 16px;
            max-height: 600px;
            overflow-y: auto;
            padding: 12px;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border-radius: 10px;
            border: 1px solid rgba(165, 180, 252, 0.2);
            scrollbar-width: thin;
            scrollbar-color: #A5B4FC rgba(30, 41, 59, 0.5);
        }

        #pool-list::-webkit-scrollbar {
            width: 4px;
        }

        #pool-list::-webkit-scrollbar-thumb {
            background: #A5B4FC;
            border-radius: 2px;
        }

        #pool-list::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        .pool-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            transition: transform 0.3s, border-color 0.3s;
            animation: fadeIn 0.5s ease-out;
        }

        .pool-card:hover {
            transform: scale(1.02);
            border-color: rgba(165, 180, 252, 0.4);
        }

        .pool-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(165, 180, 252, 0.2);
            padding-bottom: 8px;
        }

        .pool-card-header h3 {
            font-size: 1.2rem;
            margin: 0;
        }

        .pool-card-header span {
            font-size: 0.95rem;
            color: #A5B4FC;
            font-weight: 600;
        }

        .pool-card-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        .pool-card-details div {
            display: flex;
            flex-direction: column;
        }

        .pool-card-details label {
            font-weight: 500;
            color: #9CA3AF;
            margin-bottom: 2px;
        }

        .pool-card-details span {
            color: #F9FAFB;
            word-break: break-all;
        }

        .pool-card-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .action-cell {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            body { padding: 16px; }
            .flex-container { flex-direction: column; gap: 16px; padding: 0 12px; }
            .full-width-container { padding: 16px; }
            .bottom-bar { padding: 12px; }
            .bottom-bar-content { flex-direction: column; gap: 12px; align-items: stretch; }
            h2 { font-size: 1.4rem; }
            h3 { font-size: 1.1rem; }
            label { font-size: 0.85rem; }
            button { font-size: 0.9rem; padding: 8px 12px; }
            input, select { font-size: 0.9rem; padding: 8px; }
            .stake-amount-input { width: 100%; }
            .action-cell { flex-direction: column; gap: 8px; align-items: stretch; }
            .pool-card-details { grid-template-columns: 1fr; }
            .pool-card { padding: 12px; }
            .pool-card-header h3 { font-size: 1.1rem; }
            .pool-card-header span { font-size: 0.9rem; }
        }

        @media (max-width: 480px) {
            body { padding: 12px; -webkit-text-size-adjust: 100%; }
            .flex-container { padding: 0 8px; }
            .full-width-container { padding: 12px; }
            h2 { font-size: 1.3rem; }
            h3 { font-size: 1rem; }
            button { padding: 8px 10px; font-size: 0.85rem; min-height: 44px; }
            input, select { padding: 8px; font-size: 0.85rem; }
            .stake-amount-input { width: 100%; }
            .pool-card-details { font-size: 0.8rem; }
        }

        @media (min-width: 769px) {
            .full-width-container { min-width: 45%; }
        }

        @media (min-width: 992px) {
            .flex-container { padding: 0 24px; }
            h2 { font-size: 1.9rem; }
            h3 { font-size: 1.3rem; }
            button { padding: 12px 20px; }
        }
    </style>
</head>
<body>
    <div class="flex-container">
        <div class="full-width-container">
            <h2>Create Dividend Pool</h2>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="pool-token">Token Address</label>
                    <span class="help-icon" onclick="toggleHelpNote('pool-token-help')">?</span>
                </div>
                <input id="pool-token" type="text" placeholder="e.g., 0xTokenAddress" aria-label="Token Address" />
                <div id="pool-token-help" class="help-note">The token address that the dividend pool is built around.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="hard-lock-duration">Hard Lock Duration (days)</label>
                    <span class="help-icon" onclick="toggleHelpNote('hard-lock-duration-help')">?</span>
                </div>
                <input id="hard-lock-duration" type="text" placeholder="e.g., 30" inputmode="numeric" pattern="[0-9]*" aria-label="Hard Lock Duration" />
                <div id="hard-lock-duration-help" class="help-note">Amount of days staked tokens must remain locked in the contract, unable to be withdrawn.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="initial-penalty-percent">Initial Penalty Percent (%)</label>
                    <span class="help-icon" onclick="toggleHelpNote('initial-penalty-percent-help')">?</span>
                </div>
                <input id="initial-penalty-percent" type="text" placeholder="e.g., 10" inputmode="numeric" pattern="[0-9]*" aria-label="Initial Penalty Percent" />
                <div id="initial-penalty-percent-help" class="help-note">Starting percentage penalty for early withdrawal at the end of the hard lock period.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="penalty-decay-percent">Penalty Decay Percent Per Day (%)</label>
                    <span class="help-icon" onclick="toggleHelpNote('penalty-decay-percent-help')">?</span>
                </div>
                <input id="penalty-decay-percent" type="text" placeholder="e.g., 1" inputmode="decimal" aria-label="Penalty Decay Percent" />
                <div id="penalty-decay-percent-help" class="help-note">Daily reduction in penalty percentage for early withdrawal.</div>
            </div>
            <div class="launch-pool-container">
                <button id="launch-pool-button" onclick="createPool()" aria-label="Create Pool">Create Pool</button>
            </div>
        </div>

        <div class="full-width-container">
            <h2>All Dividend Pools</h2>
            <div id="pool-list">
                <div id="pool-card-container"></div>
            </div>
        </div>
    </div>

    <div class="bottom-bar">
        <div class="bottom-bar-content">
            <button id="connect-wallet-button" onclick="connectWallet()" aria-label="Connect Wallet">Connect Wallet</button>
            <select id="wallet-selector" onchange="selectWallet(this.value)" aria-label="Select Wallet">
                <option value="">-- Select Wallet --</option>
            </select>
            <p id="walletAddress">Wallet Address: Not connected</p>
            <div id="status-log"></div>
        </div>
    </div>

    <script>
        // Contract address
        const FACTORY_ADDRESS = "0xd846D1a576776a70412b473d2479362953e4C5d5";

        // Hardcoded RPC configuration for Ethereum Mainnet
        const RPC_ENDPOINTS = [
            'https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73',
            'https://rpc.ankr.com/eth',
            'https://cloudflare-eth.com'
        ];
        let currentRpcIndex = 0;

        // Regular expressions for input validation
        const addressRegex = /^0x[a-fA-F0-9]{40}$/;
        const integerRegex = /^[0-9]+$/;
        const decimalRegex = /^[0-9]+(\.[0-9]{0,18})?$/;
        const privateKeyRegex = /^0x[a-fA-F0-9]{64}$/;

        // Input validation functions
        function validateAddress(address) {
            if (!address || typeof address !== 'string') return false;
            return addressRegex.test(address.trim());
        }

        function validatePrivateKey(key) {
            if (!key || typeof key !== 'string') return false;
            return privateKeyRegex.test(key.trim());
        }

        function validateInteger(input, min = 0, max = Number.MAX_SAFE_INTEGER) {
            if (!input || typeof input !== 'string') return null;
            const trimmed = input.trim();
            if (!integerRegex.test(trimmed)) return null;
            try {
                const num = BigInt(trimmed);
                if (num < BigInt(min) || num > BigInt(max)) return null;
                return num.toString();
            } catch (e) {
                return null;
            }
        }

        function validateDecimal(input, min = 0, max = 1e18, maxDecimals = 18) {
            if (!input || typeof input !== 'string') return null;
            const trimmed = input.trim();
            if (!decimalRegex.test(trimmed)) return null;
            const [integerPart, decimalPart = ''] = trimmed.split('.');
            if (decimalPart.length > maxDecimals) return null;
            try {
                const num = parseFloat(trimmed);
                if (isNaN(num) || num < min || num > max) return null;
                const formatted = num.toFixed(maxDecimals).replace(/\.?0+$/, '');
                ethers.BigNumber.from(ethers.utils.parseUnits(formatted, maxDecimals));
                return formatted;
            } catch (e) {
                return null;
            }
        }

        // ABI for StakingPoolFactory
        const factoryAbi = [
            {
                "inputs": [
                    {"internalType": "address", "name": "token", "type": "address"},
                    {"internalType": "uint256", "name": "hardLockDuration", "type": "uint256"},
                    {"internalType": "uint256", "name": "initialPenaltyPercent", "type": "uint256"},
                    {"internalType": "uint256", "name": "penaltyDecayPercentPerDay", "type": "uint256"}
                ],
                "name": "createPool",
                "outputs": [{"internalType": "address", "name": "poolAddr", "type": "address"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {"inputs": [], "name": "DecayTooFast", "type": "error"},
            {"inputs": [], "name": "InvalidToken", "type": "error"},
            {"inputs": [], "name": "NotERC20", "type": "error"},
            {"inputs": [], "name": "ParamOutOfRange", "type": "error"},
            {"inputs": [], "name": "PoolExists", "type": "error"},
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                    {"indexed": false, "internalType": "string", "name": "reason", "type": "string"}
                ],
                "name": "PoolInitializationFailed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "poolAddress", "type": "address"},
                    {"indexed": true, "internalType": "address", "name": "token", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "hardLockDuration", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "initialPenaltyPercent", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "penaltyDecayPercentPerDay", "type": "uint256"}
                ],
                "name": "StakingPoolCreated",
                "type": "event"
            },
            {
                "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
                "name": "getPool",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "pools",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // ABI for StakingPool
        const poolAbi = [
            {
                "inputs": [
                    {"internalType": "address", "name": "_factory", "type": "address"},
                    {"internalType": "address", "name": "_token", "type": "address"},
                    {"internalType": "uint256", "name": "_hardLockDuration", "type": "uint256"},
                    {"internalType": "uint256", "name": "_initialPenaltyPercent", "type": "uint256"},
                    {"internalType": "uint256", "name": "_penaltyDecayPercentPerDay", "type": "uint256"}
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {"inputs": [], "name": "InsufficientBalance", "type": "error"},
            {"inputs": [], "name": "InvalidAmount", "type": "error"},
            {"inputs": [], "name": "InvalidToken", "type": "error"},
            {"inputs": [], "name": "Locked", "type": "error"},
            {"inputs": [], "name": "NoStake", "type": "error"},
            {
                "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
                "name": "OwnableInvalidOwner",
                "type": "error"
            },
            {
                "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
                "name": "OwnableUnauthorizedAccount",
                "type": "error"
            },
            {
                "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
                "name": "SafeERC20FailedOperation",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "oldRecip", "type": "address"},
                    {"indexed": true, "internalType": "address", "name": "newRecip", "type": "address"}
                ],
                "name": "FeeRecipientUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "previousOwner", "type": "address"},
                    {"indexed": true, "internalType": "address", "name": "newOwner", "type": "address"}
                ],
                "name": "OwnershipTransferred",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "user", "type": "address"},
                    {"indexed": false, "internalType": "address", "name": "rewardTok", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "amt", "type": "uint256"}
                ],
                "name": "RewardsClaimed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "user", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "amt", "type": "uint256"}
                ],
                "name": "Staked",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "user", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "amt", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "penalty", "type": "uint256"}
                ],
                "name": "Unstaked",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "FEE_DENOMINATOR",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "FEE_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "HARD_LOCK_DURATION",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "INITIAL_PENALTY_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "MIN_STAKE",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "PENALTY_DECAY_PERCENT_PER_DAY",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "rewardToken", "type": "address"}],
                "name": "claimReward",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address[]", "name": "rewardTokens_", "type": "address[]"}],
                "name": "claimRewards",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "cumulativeRewards",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "factoryAddress",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "feeRecipient",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "renounceOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "rewardPerTokenStored",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "name": "rewardTokens",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "", "type": "address"},
                    {"internalType": "address", "name": "", "type": "address"}
                ],
                "name": "rewards",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "amount", "type": "uint256"}],
                "name": "stake",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "stakes",
                "outputs": [
                    {"internalType": "uint256", "name": "amount", "type": "uint256"},
                    {"internalType": "uint256", "name": "stakeTimestamp", "type": "uint256"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "token",
                "outputs": [{"internalType": "contract IERC20", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "tokenBalance",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalStaked",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
                "name": "transferOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "unstake",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "newRecipient", "type": "address"}],
                "name": "updateFeeRecipient",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "", "type": "address"},
                    {"internalType": "address", "name": "", "type": "address"}
                ],
                "name": "userRewardPerTokenPaid",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {"stateMutability": "payable", "type": "receive"}
        ];

        // ABI for ERC20 token
        const erc20Abi = [
            {
                "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "spender", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "name",
                "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "symbol",
                "outputs": [{"internalType": "string", "name": "", "type": "string"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "decimals",
                "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        function getWeb3() {
            return new Web3(RPC_ENDPOINTS[currentRpcIndex]);
        }

        let web3 = getWeb3();
        let userAccount = null;
        let signer = null;
        let selectedWallet = null;
        let wallets = [];

        async function switchRpc() {
            currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
            web3 = getWeb3();
            console.log(`Switched to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
        }

        async function checkNetwork() {
            try {
                const chainId = await web3.eth.getChainId();
                if (chainId !== 1) {
                    throw new Error(`Incorrect network! Expected Ethereum Mainnet (chainId 1), got chainId ${chainId}.`);
                }
                console.log(`Connected to Ethereum Mainnet (chainId 1)`);
            } catch (error) {
                console.error(`Network check failed: ${error.message}`);
                throw error;
            }
        }

        async function withRetry(fn, maxRetries = 3, delayMs = 1000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await checkNetwork();
                    return await fn();
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    console.error(`Attempt ${attempt} failed: ${error.message}. Retrying with RPC ${RPC_ENDPOINTS[currentRpcIndex]}...`);
                    await switchRpc();
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
        }

        function loadStatusLog() {
            const savedLogs = JSON.parse(localStorage.getItem('statusLogs') || '[]');
            const statusLog = document.getElementById('status-log');
            statusLog.innerHTML = '';
            savedLogs.forEach(log => {
                const entry = document.createElement('div');
                entry.className = `status-entry ${log.type}`;
                entry.innerHTML = `
                    <span class="status-timestamp">[${log.timestamp}]</span>
                    <span>${log.emoji} ${log.message}</span>
                `;
                statusLog.appendChild(entry);
            });
            statusLog.scrollTop = statusLog.scrollHeight;
        }

        function logStatus(message, type = 'pending') {
            console.log(message);
            const statusLog = document.getElementById('status-log');
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const emoji = type === 'success' ? '🚀' : type === 'error' ? '🌈' : '';
            const entry = document.createElement('div');
            entry.className = `status-entry ${type}`;
            entry.innerHTML = `
                <span class="status-timestamp">[${timestamp}]</span>
                <span>${emoji} ${message}</span>
            `;
            statusLog.appendChild(entry);
            statusLog.scrollTop = statusLog.scrollHeight;

            // Save to local storage
            const savedLogs = JSON.parse(localStorage.getItem('statusLogs') || '[]');
            savedLogs.push({ timestamp, message, type, emoji });
            // Limit to 50 logs to prevent excessive storage
            if (savedLogs.length > 50) savedLogs.shift();
            localStorage.setItem('statusLogs', JSON.stringify(savedLogs));
        }

        function showSpinner(button) {
            button.disabled = true;
            const originalText = button.innerHTML;
            button.innerHTML = '<span class="spinner"></span>';
            return originalText;
        }

        function hideSpinner(button, originalText) {
            button.disabled = false;
            button.innerHTML = originalText;
        }

        function toggleHelpNote(noteId) {
            const note = document.getElementById(noteId);
            if (note.classList.contains('active')) {
                note.classList.remove('active');
            } else {
                // Close other open notes
                document.querySelectorAll('.help-note.active').forEach(n => n.classList.remove('active'));
                note.classList.add('active');
            }
        }

        async function connectWallet() {
            const button = document.getElementById('connect-wallet-button');
            const originalText = showSpinner(button);
            logStatus("Connecting wallet...");
            try {
                if (!window.ethereum) {
                    logStatus("Please install MetaMask to use this feature.", 'error');
                    return;
                }
                web3 = new Web3(window.ethereum);
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();

                await window.ethereum.request({ method: "eth_requestAccounts" });
                userAccount = (await web3.eth.getAccounts())[0];
                document.getElementById("walletAddress").innerText = `Wallet: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                logStatus("Wallet connected successfully!", 'success');

                await initializeWallets();
                await refreshPools();
            } catch (error) {
                console.error(`Wallet connection error: ${error.message}`);
                logStatus(`Failed to connect wallet: ${error.message}`, 'error');
                signer = null;
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function initializeWallets() {
            try {
                console.log("Initializing wallets...");
                wallets = JSON.parse(localStorage.getItem('wallets') || '[]');

                if (window.ethereum && userAccount) {
                    const metamaskWallet = { address: userAccount, type: 'MetaMask', isMetaMask: true };
                    if (!wallets.some(w => w.address === metamaskWallet.address && w.type === 'MetaMask')) {
                        wallets = wallets.filter(w => w.type !== 'MetaMask');
                        wallets.push(metamaskWallet);
                    }
                }

                wallets = wallets.map(wallet => {
                    if (wallet.type === 'MoneyFund' && wallet.privateKey) {
                        if (!validatePrivateKey(wallet.privateKey)) {
                            console.error(`Invalid private key for MoneyFund wallet: ${wallet.address}`);
                            return null;
                        }
                        return { ...wallet, isMetaMask: false };
                    }
                    return wallet;
                }).filter(wallet => wallet !== null);

                localStorage.setItem('wallets', JSON.stringify(wallets));

                const walletSelector = document.getElementById('wallet-selector');
                walletSelector.innerHTML = '<option value="">-- Select Wallet --</option>';
                wallets.forEach((wallet, index) => {
                    if (wallet.address && validateAddress(wallet.address)) {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${wallet.type}: ${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
                        walletSelector.appendChild(option);
                    } else {
                        console.error(`Invalid wallet at index ${index}: missing or invalid address`);
                    }
                });

                const selectedIndex = parseInt(localStorage.getItem('selectedWalletIndex'));
                console.log(`Stored selectedWalletIndex: ${selectedIndex}`);

                if (wallets.length > 0 && !isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < wallets.length) {
                    selectedWallet = wallets[selectedIndex];
                    userAccount = selectedWallet.address;
                    walletSelector.value = selectedIndex;
                    document.getElementById("walletAddress").innerText = `Wallet: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                    if (selectedWallet.isMetaMask && window.ethereum) {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (!accounts || accounts.length === 0 || accounts[0].toLowerCase() !== selectedWallet.address.toLowerCase()) {
                            console.log("MetaMask selected but not connected. Requesting connection.");
                            await connectWallet();
                        } else {
                            const provider = new ethers.providers.Web3Provider(window.ethereum);
                            signer = provider.getSigner();
                        }
                    } else {
                        if (!web3) {
                            web3 = getWeb3();
                        }
                        signer = null;
                        if (selectedWallet.type === 'MoneyFund' && !validatePrivateKey(selectedWallet.privateKey)) {
                            throw new Error(`Invalid private key for MoneyFund wallet: ${selectedWallet.address}`);
                        }
                    }
                    console.log(`Selected wallet: ${userAccount}`);
                    await refreshPools();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    walletSelector.value = "";
                    document.getElementById("walletAddress").innerText = "Wallet: Not connected";
                    console.log("No valid wallet selected");
                }
            } catch (error) {
                console.error(`Wallet initialization error: ${error.message}`);
                document.getElementById("walletAddress").innerText = "Wallet: Error loading wallets";
                logStatus(`Wallet initialization failed: ${error.message}`, 'error');
                signer = null;
            }
        }

        function selectWallet(index) {
            try {
                const idx = parseInt(index);
                if (idx >= 0 && idx < wallets.length && wallets[idx].address && validateAddress(wallets[idx].address)) {
                    selectedWallet = wallets[idx];
                    localStorage.setItem('selectedWalletIndex', idx);
                    userAccount = selectedWallet.address;
                    document.getElementById("walletAddress").innerText = `Wallet: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;

                    if (selectedWallet.isMetaMask) {
                        if (window.ethereum) {
                            connectWallet();
                        } else {
                            console.error("MetaMask extension not detected.");
                            logStatus("MetaMask extension not detected.", 'error');
                            selectedWallet = null;
                            userAccount = null;
                            signer = null;
                            document.getElementById("walletAddress").innerText = "Wallet: Not connected";
                            document.getElementById('wallet-selector').value = "";
                            localStorage.removeItem('selectedWalletIndex');
                        }
                    } else {
                        web3 = getWeb3();
                        signer = null;
                        if (selectedWallet.type === 'MoneyFund' && !validatePrivateKey(selectedWallet.privateKey)) {
                            throw new Error(`Invalid private key for MoneyFund wallet: ${selectedWallet.address}`);
                        }
                    }
                    console.log(`Selected wallet: ${userAccount}`);
                    refreshPools();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    localStorage.removeItem('selectedWalletIndex');
                    document.getElementById("walletAddress").innerText = "Wallet: Not connected";
                    document.getElementById('wallet-selector').value = "";
                    web3 = getWeb3();
                    console.log("Invalid wallet selection");
                }
            } catch (error) {
                console.error(`Wallet selection error: ${error.message}`);
                logStatus(`Failed to select wallet: ${error.message}`, 'error');
                signer = null;
            }
        }

        async function getGasPrice() {
            return await withRetry(async () => {
                const baseGasPrice = BigInt(await web3.eth.getGasPrice());
                const baseGasPriceGwei = Number(web3.utils.fromWei(baseGasPrice.toString(), 'gwei'));
                const adjustedGasPriceGwei = Math.max(1, baseGasPriceGwei * 1.25);
                return web3.utils.toWei(adjustedGasPriceGwei.toFixed(0), 'gwei');
            });
        }

        async function checkWalletBalance(address, gasLimit, gasPrice) {
            try {
                const balance = await withRetry(() => web3.eth.getBalance(address));
                const requiredGas = BigInt(gasLimit) * BigInt(gasPrice);
                if (BigInt(balance) < requiredGas) {
                    throw new Error(
                        `Insufficient ETH balance: need ${web3.utils.fromWei(requiredGas.toString(), 'ether')} ETH, have ${web3.utils.fromWei(balance, 'ether')} ETH`
                    );
                }
                return true;
            } catch (error) {
                console.error(`Wallet balance check failed: ${error.message}`);
                throw error;
            }
        }

        async function createPool() {
            const button = document.getElementById('launch-pool-button');
            const originalText = showSpinner(button);
            logStatus("Initiating dividend pool creation...");
            try {
                console.log("createPool function triggered");
                if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                    console.error("No wallet selected or connected");
                    logStatus("Please connect and select a wallet first.", 'error');
                    return;
                }
                console.log(`Wallet connected: ${userAccount}`);

                const token = document.getElementById("pool-token").value;
                const hardLockDuration = document.getElementById("hard-lock-duration").value;
                const initialPenaltyPercent = document.getElementById("initial-penalty-percent").value;
                const penaltyDecayPercent = document.getElementById("penalty-decay-percent").value;

                console.log(`Inputs: token=${token}, hardLockDuration=${hardLockDuration}, initialPenaltyPercent=${initialPenaltyPercent}, penaltyDecayPercent=${penaltyDecayPercent}`);

                if (!token || !hardLockDuration || !initialPenaltyPercent || !penaltyDecayPercent) {
                    console.error("Missing input fields");
                    logStatus("Please fill in all fields.", 'error');
                    return;
                }

                if (!validateAddress(token)) {
                    console.error(`Invalid token address: ${token}`);
                    logStatus(`Invalid token address: ${token}`, 'error');
                    return;
                }

                const hardLockDurationNum = validateInteger(hardLockDuration, 0);
                if (!hardLockDurationNum) {
                    console.error("Invalid hard lock duration");
                    logStatus("Hard lock duration must be a non-negative integer.", 'error');
                    return;
                }

                const initialPenaltyPercentNum = validateInteger(initialPenaltyPercent, 0, 100);
                if (!initialPenaltyPercentNum) {
                    console.error("Invalid initial penalty percent");
                    logStatus("Initial penalty percent must be an integer between 0 and 100.", 'error');
                    return;
                }

                const penaltyDecayPercentNum = validateDecimal(penaltyDecayPercent, 0, 100, 4);
                if (!penaltyDecayPercentNum) {
                    console.error("Invalid penalty decay percent");
                    logStatus("Penalty decay percent must be a number between 0 and 100 with up to 4 decimal places.", 'error');
                    return;
                }

                const hardLockSeconds = BigInt(hardLockDurationNum) * BigInt(86400);
                const initialPenaltyBps = BigInt(initialPenaltyPercentNum) * BigInt(100);
                const penaltyDecayBps = ethers.utils.parseUnits(penaltyDecayPercentNum, 2);

                logStatus("Preparing to create dividend pool...");
                console.log("Creating contract instance");
                const factory = new web3.eth.Contract(factoryAbi, FACTORY_ADDRESS);

                let gasEstimate;
                try {
                    console.log("Estimating gas");
                    gasEstimate = await withRetry(() =>
                        factory.methods.createPool(
                            token,
                            hardLockSeconds.toString(),
                            initialPenaltyBps.toString(),
                            penaltyDecayBps.toString()
                        ).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Estimated gas limit: ${gasEstimate}`);
                } catch (err) {
                    gasEstimate = 1500000;
                    console.error(`Gas estimation failed, using default ${gasEstimate}: ${err.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                logStatus(selectedWallet.isMetaMask ? "Creating pool... Please confirm in MetaMask." : "Creating pool... Signing with MoneyFund wallet.");
                console.log("Initiating transaction");

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    console.log("Using MetaMask for transaction");
                    const factoryEthers = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);
                    tx = await factoryEthers.createPool(
                        token,
                        hardLockSeconds.toString(),
                        initialPenaltyBps.toString(),
                        penaltyDecayBps,
                        {
                            gasLimit: gasEstimate,
                            gasPrice: gasPrice
                        }
                    );
                    console.log("Waiting for transaction confirmation");
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    console.log("Using MoneyFund wallet for transaction");
                    const txData = factory.methods.createPool(
                        token,
                        hardLockSeconds.toString(),
                        initialPenaltyBps.toString(),
                        penaltyDecayBps.toString()
                    ).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: FACTORY_ADDRESS,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                    console.log("Transaction sent and confirmed");
                }

                const poolAddress = tx.logs.find(log => {
                    try {
                        const iface = new ethers.utils.Interface(factoryAbi);
                        const parsedLog = iface.parseLog(log);
                        return parsedLog.name === 'StakingPoolCreated';
                    } catch (e) {
                        return false;
                    }
                })?.args.poolAddress;

                if (!validateAddress(poolAddress)) {
                    throw new Error("Invalid pool address received.");
                }

                logStatus(`Dividend pool for token ${token.slice(0, 6)}...${token.slice(-4)} created at: ${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}!`, 'success');
                console.log(`Dividend pool created at: ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                await refreshPools();
            } catch (err) {
                console.error(`Pool creation failed: ${err.message}`);
                logStatus(`Failed to create dividend pool: ${err.message}`, 'error');
                alert(`Failed to create dividend pool: ${err.message}. Check the console for details.`);
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function stakeTokens(poolAddress, amount) {
            console.log(`Attempting to stake ${amount} tokens in pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            const validatedAmount = validateDecimal(amount, 0.00000001, 1e18, 18);
            if (!validatedAmount) {
                console.error(`Invalid stake amount: ${amount}`);
                return { error: "Please enter a valid positive amount with up to 18 decimals." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const tokenAddress = await withRetry(() => pool.methods.token().call());
                if (!validateAddress(tokenAddress)) {
                    throw new Error("Invalid token address retrieved from pool.");
                }

                const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
                const decimals = await withRetry(() => tokenContract.methods.decimals().call());
                if (typeof decimals !== 'string' && typeof decimals !== 'number') {
                    throw new Error("Invalid token decimals.");
                }
                const maxDecimals = Math.min(Number(decimals), 18);
                const reValidatedAmount = validateDecimal(validatedAmount, 0.00000001, 1e18, maxDecimals);
                if (!reValidatedAmount) {
                    throw new Error(`Amount exceeds token's decimal precision (${maxDecimals} decimals).`);
                }

                const amountWei = ethers.utils.parseUnits(reValidatedAmount, decimals);
                const amountWeiStr = amountWei.toString();

                const tokenBalance = await withRetry(() => tokenContract.methods.balanceOf(userAccount).call());
                if (ethers.BigNumber.from(tokenBalance).lt(amountWei)) {
                    throw new Error(
                        `Insufficient token balance: need ${reValidatedAmount} tokens, have ${ethers.utils.formatUnits(tokenBalance, decimals)} tokens`
                    );
                }

                let approveGasEstimate;
                try {
                    approveGasEstimate = await withRetry(() =>
                        tokenContract.methods.approve(poolAddress, amountWeiStr).estimateGas({ from: userAccount })
                    );
                    approveGasEstimate = Math.ceil(Number(approveGasEstimate) * 1.2);
                } catch (error) {
                    approveGasEstimate = 100000;
                    console.error(`Approve gas estimation failed, using default ${approveGasEstimate}: ${error.message}`);
                }

                let stakeGasEstimate;
                try {
                    stakeGasEstimate = await withRetry(() =>
                        pool.methods.stake(amountWeiStr).estimateGas({ from: userAccount })
                    );
                    stakeGasEstimate = Math.ceil(Number(stakeGasEstimate) * 1.2);
                    console.log(`Stake gas limit: ${stakeGasEstimate}`);
                } catch (error) {
                    stakeGasEstimate = 1500000;
                    console.error(`Stake gas estimation failed, using default ${stakeGasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, approveGasEstimate + stakeGasEstimate, gasPrice);

                let approveTx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const tokenEthers = new ethers.Contract(tokenAddress, erc20Abi, signer);
                    approveTx = await tokenEthers.approve(poolAddress, amountWei, {
                        gasLimit: approveGasEstimate,
                        gasPrice: gasPrice
                    });
                    await approveTx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const approveTxData = tokenContract.methods.approve(poolAddress, amountWeiStr).encodeABI();
                    const approveNonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const approveTransactionObject = {
                        from: userAccount,
                        to: tokenAddress,
                        data: approveTxData,
                        gas: approveGasEstimate,
                        gasPrice: gasPrice,
                        nonce: approveNonce
                    };
                    const signedApproveTx = await web3.eth.accounts.signTransaction(approveTransactionObject, selectedWallet.privateKey);
                    approveTx = await withRetry(() => web3.eth.sendSignedTransaction(signedApproveTx.rawTransaction));
                }

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.stake(amountWei, {
                        gasLimit: stakeGasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const txData = pool.methods.stake(amountWeiStr).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: stakeGasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Staked ${reValidatedAmount} tokens in pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Staked ${reValidatedAmount} tokens successfully!` };
            } catch (error) {
                console.error(`Stake failed: ${error.message}`);
                return { error: `Stake failed: ${error.message}` };
            }
        }

        async function unstakeTokens(poolAddress) {
            console.log(`Attempting to unstake tokens from pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const stakeInfo = await withRetry(() => pool.methods.stakes(userAccount).call());
                if (stakeInfo.amount === '0') {
                    throw new Error("No staked tokens to unstake.");
                }

                let gasEstimate;
                try {
                    gasEstimate = await withRetry(() =>
                        pool.methods.unstake().estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Unstake gas limit: ${gasEstimate}`);
                } catch (error) {
                    gasEstimate = 1500000;
                    console.error(`Unstake gas estimation failed, using default ${gasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.unstake({
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const txData = pool.methods.unstake().encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Unstaked tokens from pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Unstaked tokens successfully!` };
            } catch (error) {
                console.error(`Unstake failed: ${error.message}`);
                return { error: `Unstake failed: ${error.message}` };
            }
        }

        async function claimRewards(poolAddress, rewardTokens) {
            console.log(`Attempting to claim rewards from pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            if (!rewardTokens.every(validateAddress)) {
                console.error("Invalid reward token addresses");
                return { error: "Invalid reward token addresses." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                let gasEstimate;
                try {
                    gasEstimate = await withRetry(() =>
                        pool.methods.claimRewards(rewardTokens).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Claim rewards gas limit: ${gasEstimate}`);
                } catch (error) {
                    gasEstimate = 1500000;
                    console.error(`Claim rewards gas estimation failed, using default ${gasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.claimRewards(rewardTokens, {
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const txData = pool.methods.claimRewards(rewardTokens).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Claimed rewards from pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Claimed rewards successfully!` };
            } catch (error) {
                console.error(`Claim rewards failed: ${error.message}`);
                return { error: `Claim rewards failed: ${error.message}` };
            }
        }

        async function getPoolInfo(poolAddress) {
            try {
                if (!validateAddress(poolAddress)) {
                    throw new Error(`Invalid pool address: ${poolAddress}`);
                }
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const tokenAddress = await withRetry(() => pool.methods.token().call());
                if (!validateAddress(tokenAddress)) {
                    throw new Error(`Invalid token address for pool ${poolAddress}`);
                }

                const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
                let decimals, name, symbol;
                try {
                    decimals = await withRetry(() => tokenContract.methods.decimals().call());
                    if (typeof decimals !== 'string' && typeof decimals !== 'number') {
                        throw new Error("Invalid token decimals");
                    }
                } catch (e) {
                    decimals = 18;
                    console.error(`Failed to fetch decimals for token ${tokenAddress}: ${e.message}`);
                }

                try {
                    name = await withRetry(() => tokenContract.methods.name().call());
                    if (typeof name !== 'string') {
                        throw new Error("Invalid token name");
                    }
                } catch (e) {
                    name = "Unknown Token";
                    console.error(`Failed to fetch name for token ${tokenAddress}: ${e.message}`);
                }

                try {
                    symbol = await withRetry(() => tokenContract.methods.symbol().call());
                    if (typeof symbol !== 'string') {
                        throw new Error("Invalid token symbol");
                    }
                } catch (e) {
                    symbol = "UNKNOWN";
                    console.error(`Failed to fetch symbol for token ${tokenAddress}: ${e.message}`);
                }

                const hardLockDuration = await withRetry(() => pool.methods.HARD_LOCK_DURATION().call());
                const initialPenaltyPercent = await withRetry(() => pool.methods.INITIAL_PENALTY_PERCENT().call());
                const penaltyDecayPercentPerDay = await withRetry(() => pool.methods.PENALTY_DECAY_PERCENT_PER_DAY().call());
                const totalStaked = await withRetry(() => pool.methods.totalStaked().call());
                let stakeInfo = { amount: '0', stakeTimestamp: '0' };
                try {
                    stakeInfo = await withRetry(() => pool.methods.stakes(userAccount || ethers.constants.AddressZero).call());
                } catch (e) {
                    console.error(`Failed to fetch stake info for user ${userAccount} in pool ${poolAddress}: ${e.message}`);
                }

                const feeRecipient = await withRetry(() => pool.methods.feeRecipient().call());
                if (!validateAddress(feeRecipient)) {
                    throw new Error(`Invalid fee recipient address for pool ${poolAddress}`);
                }

                return {
                                        poolAddress,
                    tokenAddress,
                    name,
                    symbol,
                    hardLockDuration: Number(hardLockDuration) / 86400,
                    initialPenaltyPercent: Number(initialPenaltyPercent) / 100,
                    penaltyDecayPercentPerDay: Number(penaltyDecayPercentPerDay) / 100,
                    totalStaked: ethers.utils.formatUnits(totalStaked, decimals),
                    userStake: ethers.utils.formatUnits(stakeInfo.amount, decimals),
                    stakeTimestamp: Number(stakeInfo.stakeTimestamp),
                    feeRecipient
                };
            } catch (error) {
                console.error(`Failed to fetch pool info for ${poolAddress}: ${error.message}`);
                return { error: `Failed to fetch pool info: ${error.message}`, poolAddress };
            }
        }

        // Helper function to format addresses safely
        const formatAddress = (addr) => validateAddress(addr) ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : 'Invalid Address';

        async function refreshPools() {
            logStatus("Loading dividend pools...");
            try {
                const factory = new web3.eth.Contract(factoryAbi, FACTORY_ADDRESS);
                const pastEvents = await withRetry(() =>
                    factory.getPastEvents('StakingPoolCreated', {
                        fromBlock: 0,
                        toBlock: 'latest'
                    })
                );

                const pools = pastEvents.map(event => {
                    const poolAddress = event.returnValues.poolAddress;
                    if (!validateAddress(poolAddress)) {
                        console.error(`Invalid pool address in event: ${poolAddress}`);
                        return null;
                    }
                    return {
                        poolAddress,
                        token: event.returnValues.token,
                        hardLockDuration: Number(event.returnValues.hardLockDuration) / 86400,
                        initialPenaltyPercent: Number(event.returnValues.initialPenaltyPercent) / 100,
                        penaltyDecayPercentPerDay: Number(event.returnValues.penaltyDecayPercentPerDay) / 100
                    };
                }).filter(pool => pool !== null);

                const cardContainer = document.getElementById("pool-card-container");
                cardContainer.innerHTML = "";

                if (pools.length === 0) {
                    cardContainer.innerHTML = '<p style="text-align: center; color: #D1D5DB;">No dividend pools found.</p>';
                    logStatus("No dividend pools available.");
                    return;
                }

                let validPoolCount = 0;
                for (const pool of pools) {
                    const poolInfo = await getPoolInfo(pool.poolAddress);
                    if (poolInfo.error) {
                        console.error(`Skipping pool ${pool.poolAddress}: ${poolInfo.error}`);
                        continue;
                    }

                    // Validate all required properties before rendering
                    if (
                        !validateAddress(poolInfo.poolAddress) ||
                        !validateAddress(poolInfo.tokenAddress) ||
                        !validateAddress(poolInfo.feeRecipient) ||
                        typeof poolInfo.name !== 'string' ||
                        typeof poolInfo.symbol !== 'string' ||
                        isNaN(poolInfo.hardLockDuration) ||
                        isNaN(poolInfo.initialPenaltyPercent) ||
                        isNaN(poolInfo.penaltyDecayPercentPerDay) ||
                        isNaN(parseFloat(poolInfo.totalStaked)) ||
                        isNaN(parseFloat(poolInfo.userStake)) ||
                        isNaN(poolInfo.stakeTimestamp)
                    ) {
                        console.error(`Invalid pool data for ${poolInfo.poolAddress}, skipping.`);
                        continue;
                    }

                    validPoolCount++;
                    const card = document.createElement('div');
                    card.className = 'pool-card';
                    card.innerHTML = `
                        <div class="pool-card-header">
                            <h3>${poolInfo.name} (${poolInfo.symbol})</h3>
                            <span>${formatAddress(poolInfo.poolAddress)}</span>
                        </div>
                        <div class="pool-card-details">
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Token Address</label>
                                    <span class="help-icon" onclick="toggleHelpNote('token-address-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${formatAddress(poolInfo.tokenAddress)}</span>
                                <button class="copy-button" onclick="copyToClipboard('${poolInfo.tokenAddress}')">Copy</button>
                                <div id="token-address-help-${poolInfo.poolAddress}" class="help-note">The ERC20 token address for this dividend pool.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Hard Lock Duration</label>
                                    <span class="help-icon" onclick="toggleHelpNote('hard-lock-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${poolInfo.hardLockDuration.toFixed(2)} days</span>
                                <div id="hard-lock-help-${poolInfo.poolAddress}" class="help-note">Minimum days tokens must be staked before penalty-free withdrawal.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Initial Penalty</label>
                                    <span class="help-icon" onclick="toggleHelpNote('initial-penalty-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${poolInfo.initialPenaltyPercent.toFixed(2)}%</span>
                                <div id="initial-penalty-help-${poolInfo.poolAddress}" class="help-note">Penalty percentage for early withdrawal at lock start.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Penalty Decay/Day</label>
                                    <span class="help-icon" onclick="toggleHelpNote('penalty-decay-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${poolInfo.penaltyDecayPercentPerDay.toFixed(4)}%</span>
                                <div id="penalty-decay-help-${poolInfo.poolAddress}" class="help-note">Daily reduction in early withdrawal penalty.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Total Staked</label>
                                    <span class="help-icon" onclick="toggleHelpNote('total-staked-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${parseFloat(poolInfo.totalStaked).toFixed(4)} ${poolInfo.symbol}</span>
                                <div id="total-staked-help-${poolInfo.poolAddress}" class="help-note">Total tokens staked in this pool by all users.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Your Stake</label>
                                    <span class="help-icon" onclick="toggleHelpNote('user-stake-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${parseFloat(poolInfo.userStake).toFixed(4)} ${poolInfo.symbol}</span>
                                <div id="user-stake-help-${poolInfo.poolAddress}" class="help-note">Your current staked tokens in this pool.</div>
                            </div>
                            <div class="field-container">
                                <div class="label-with-help">
                                    <label>Fee Recipient</label>
                                    <span class="help-icon" onclick="toggleHelpNote('fee-recipient-help-${poolInfo.poolAddress}')" aria-label="Toggle help note">?</span>
                                </div>
                                <span>${formatAddress(poolInfo.feeRecipient)}</span>
                                <div id="fee-recipient-help-${poolInfo.poolAddress}" class="help-note">Address receiving fees from this pool.</div>
                            </div>
                        </div>
                        <div class="pool-card-actions">
                            <div class="action-cell">
                                <input type="text" class="stake-amount-input" id="stake-amount-${poolInfo.poolAddress}" placeholder="Amount" inputmode="decimal" aria-label="Stake Amount" />
                                <button class="stake-button" onclick="handleStake('${poolInfo.poolAddress}')">Stake</button>
                                <button class="unstake-button" onclick="handleUnstake('${poolInfo.poolAddress}')">Unstake</button>
                                <button class="claim-rewards-button" onclick="handleClaimRewards('${poolInfo.poolAddress}', ['${poolInfo.tokenAddress}'])">Claim Rewards</button>
                            </div>
                        </div>
                    `;
                    cardContainer.appendChild(card);
                }

                if (validPoolCount === 0) {
                    cardContainer.innerHTML = '<p style="text-align: center; color: #D1D5DB;">No valid dividend pools found.</p>';
                    logStatus("No valid dividend pools available.");
                } else {
                    logStatus(`Loaded ${validPoolCount} dividend pool${validPoolCount > 1 ? 's' : ''} successfully!`, 'success');
                }
            } catch (error) {
                console.error(`Failed to refresh dividend pools: ${error.message}`);
                logStatus(`Failed to load dividend pools: ${error.message}`, 'error');
            }
        }

        function copyToClipboard(text) {
            if (!validateAddress(text)) {
                console.error(`Cannot copy invalid address: ${text}`);
                logStatus(`Cannot copy invalid address: ${text}`, 'error');
                alert('Invalid address cannot be copied.');
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                console.log(`Copied address to clipboard: ${formatAddress(text)}`);
                logStatus(`Copied ${formatAddress(text)} to clipboard!`, 'success');
            }).catch(err => {
                console.error(`Failed to copy address: ${err.message}`);
                logStatus(`Failed to copy address: ${err.message}`, 'error');
            });
        }

        async function handleStake(poolAddress) {
            const input = document.getElementById(`stake-amount-${poolAddress}`);
            const stakeButton = input.nextElementSibling; // Assumes stake button is next
            const originalText = showSpinner(stakeButton);
            logStatus("Processing stake...");

            const amount = input.value.trim();
            if (!amount) {
                logStatus("Please enter an amount to stake.", 'error');
                hideSpinner(stakeButton, originalText);
                return;
            }

            const result = await stakeTokens(poolAddress, amount);
            if (result.success) {
                logStatus(result.success, 'success');
                input.value = '';
                await refreshPools();
            } else {
                logStatus(result.error, 'error');
            }
            hideSpinner(stakeButton, originalText);
        }

        async function handleUnstake(poolAddress) {
            const unstakeButton = document.querySelector(`#stake-amount-${poolAddress}`).parentElement.querySelector('.unstake-button');
            const originalText = showSpinner(unstakeButton);
            logStatus("Processing unstake...");

            const result = await unstakeTokens(poolAddress);
            if (result.success) {
                logStatus(result.success, 'success');
                await refreshPools();
            } else {
                logStatus(result.error, 'error');
            }
            hideSpinner(unstakeButton, originalText);
        }

        async function handleClaimRewards(poolAddress, rewardTokens) {
            const claimButton = document.querySelector(`#stake-amount-${poolAddress}`).parentElement.querySelector('.claim-rewards-button');
            const originalText = showSpinner(claimButton);
            logStatus("Processing reward claim...");

            const result = await claimRewards(poolAddress, rewardTokens);
            if (result.success) {
                logStatus(result.success, 'success');
                await refreshPools();
            } else {
                logStatus(result.error, 'error');
            }
            hideSpinner(claimButton, originalText);
        }

        // Initialize on page load
        window.addEventListener('load', async () => {
            try {
                console.log("Page loaded, initializing...");
                loadStatusLog();
                await initializeWallets();
                if (selectedWallet && userAccount) {
                    await refreshPools();
                } else {
                    console.log("No wallet selected on page load");
                    logStatus("Please connect a wallet to view dividend pools.");
                }
            } catch (error) {
                console.error(`Initialization error: ${error.message}`);
                logStatus(`Initialization failed: ${error.message}`, 'error');
            }
        });

        // Handle MetaMask account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async (accounts) => {
                if (accounts.length === 0) {
                    console.log("MetaMask disconnected");
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    document.getElementById("walletAddress").innerText = "Wallet: Not connected";
                    document.getElementById('wallet-selector').value = "";
                    localStorage.removeItem('selectedWalletIndex');
                    await initializeWallets();
                    logStatus("Wallet disconnected.", 'error');
                } else if (selectedWallet && selectedWallet.isMetaMask && accounts[0].toLowerCase() !== userAccount.toLowerCase()) {
                    console.log(`MetaMask account changed to ${accounts[0]}`);
                    userAccount = accounts[0];
                    document.getElementById("walletAddress").innerText = `Wallet: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    await initializeWallets();
                    await refreshPools();
                    logStatus(`Wallet changed to ${formatAddress(accounts[0])}`, 'success');
                }
            });

            window.ethereum.on('chainChanged', async () => {
                console.log("Network changed, rechecking...");
                await checkNetwork().catch(() => {
                    logStatus("Please switch to Ethereum Mainnet.", 'error');
                });
                if (selectedWallet && userAccount) {
                    await refreshPools();
                }
            });
        }
    </script>
</body>
</html>
