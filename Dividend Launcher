<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoneyFund Dividend Pool Launchpad</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #F9FAFB;
            min-height: 100vh;
            line-height: 1.6;
            background: linear-gradient(135deg, #0B0F24, #1A1E3B);
            padding: 24px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" opacity="0.05"%3E%3Cdefs%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3C/defs%3E%3Crect width="100%" height="100%" filter="url(%23noise)"/%3E%3C/svg%3E');
            z-index: -1;
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .full-width-container {
            flex: 1;
            min-width: 320px;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            margin-bottom: 24px;
            transition: transform 0.3s ease;
        }

        .full-width-container:hover {
            transform: translateY(-4px);
        }

        .launch-pool-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
        }

        .bottom-bar {
            max-width: 1280px;
            margin: 24px auto 0;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .bottom-bar-content {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: nowrap;
            justify-content: space-between;
        }

        #status-log {
            max-height: 100px;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.85rem;
            background: rgba(17, 24, 39, 0.8);
            color: #D1D5DB;
            border-radius: 8px;
            width: 100%;
            max-width: 800px;
            scrollbar-width: thin;
            scrollbar-color: #A5B4FC rgba(30, 41, 59, 0.5);
        }

        #status-log::-webkit-scrollbar {
            width: 4px;
        }

        #status-log::-webkit-scrollbar-thumb {
            background: #A5B4FC;
            border-radius: 2px;
        }

        #status-log::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        .status-entry {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid rgba(165, 180, 252, 0.1);
            animation: fadeIn 0.3s ease-out;
            font-size: 0.85rem;
        }

        .status-entry.success {
            color: #34D399;
        }

        .status-entry.pending {
            color: #F9FAFB;
            background: rgba(255, 255, 255, 0.05);
        }

        .status-entry.error {
            color: #F87171;
        }

        .status-entry a {
            color: #A5B4FC;
            text-decoration: none;
        }

        .status-entry a:hover {
            text-decoration: underline;
        }

        .status-timestamp {
            color: #9CA3AF;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        button {
            padding: 10px 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #4F46E5, #7C3AED);
            color: #F9FAFB;
            font-weight: 600;
            font-size: 0.95rem;
            transition: transform 0.2s, background 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
            min-height: 48px;
        }

        button:hover {
            background: linear-gradient(90deg, #4338CA, #6D28D9);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }

        button:active::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            transform: scale(1);
            transition: transform 0.2s;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #F9FAFB;
            border-top: none;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #connect-wallet-button, #launch-pool-button {
            padding: 12px 24px;
        }

        .stake-button, .unstake-button, .claim-rewards-button {
            padding: 8px 12px;
            font-size: 0.9rem;
        }

        .copy-button {
            background: #6B7280;
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        .copy-button:hover {
            background: #4B5563;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 8px;
            background: rgba(17, 24, 39, 0.8);
            color: #F9FAFB;
            font-size: 0.95rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: border 0.3s, box-shadow 0.3s;
        }

        input:focus, select:focus {
            border: 1px solid #A5B4FC;
            box-shadow: 0 0 8px rgba(165, 180, 252, 0.5);
            outline: none;
        }

        .stake-amount-input {
            width: 120px;
            margin-right: 8px;
        }

        input::placeholder {
            color: #9CA3AF;
            opacity: 0.7;
        }

        select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="292.4" height="292.4"><path fill="%23F9FAFB" d="M287 69.4a17.6 17.6 0 00-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 000 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.2-5.5-12.8z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 10px auto;
            padding-right: 32px;
            max-width: 200px;
        }

        h2 {
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #FFFFFF;
            text-align: center;
            margin-bottom: 16px;
        }

        h3 {
            font-size: 1.3rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: #FFFFFF;
            margin: 12px 0 8px;
        }

        label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #D1D5DB;
            margin-bottom: 4px;
            display: block;
        }

        .field-container {
            position: relative;
            margin-bottom: 12px;
        }

        .label-with-help {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .help-icon {
            cursor: pointer;
            font-size: 0.8rem;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            border-radius: 50%;
            background: #6B7280;
            color: #F9FAFB;
            transition: background 0.3s;
        }

        .help-icon:hover {
            background: #4B5563;
        }

        .help-note {
            display: none;
            font-size: 0.8rem;
            color: #D1D5DB;
            background: rgba(17, 24, 39, 0.9);
            padding: 8px;
            border-radius: 6px;
            margin-top: 4px;
            border: 1px solid rgba(165, 180, 252, 0.2);
            max-width: 300px;
        }

        .help-note.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #pool-list {
            margin-top: 16px;
            max-height: 600px;
            overflow-y: auto;
            padding: 12px;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border-radius: 10px;
            border: 1px solid rgba(165, 180, 252, 0.2);
            scrollbar-width: thin;
            scrollbar-color: #A5B4FC rgba(30, 41, 59, 0.5);
        }

        #pool-list::-webkit-scrollbar {
            width: 4px;
        }

        #pool-list::-webkit-scrollbar-thumb {
            background: #A5B4FC;
            border-radius: 2px;
        }

        #pool-list::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        .pool-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 180, 252, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            transition: transform 0.3s, border-color 0.3s;
            animation: fadeIn 0.5s ease-out;
        }

        .pool-card:hover {
            transform: scale(1.02);
            border-color: rgba(165, 180, 252, 0.4);
        }

        .pool-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(165, 180, 252, 0.2);
            padding-bottom: 8px;
        }

        .pool-card-header h3 {
            font-size: 1.2rem;
            margin: 0;
        }

        .pool-card-header span {
            font-size: 0.95rem;
            color: #A5B4FC;
            font-weight: 600;
        }

        .pool-card-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        .pool-card-details div {
            display: flex;
            flex-direction: column;
        }

        .pool-card-details label {
            font-weight: 500;
            color: #9CA3AF;
            margin-bottom: 2px;
        }

        .pool-card-details span {
            color: #F9FAFB;
            word-break: break-all;
        }

        .pool-card-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .action-cell {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .breakeven-formula {
            font-size: 0.63rem;
        }

        @media (max-width: 768px) {
            body { padding: 16px; }
            .flex-container { flex-direction: column; gap: 16px; padding: 0 12px; }
            .full-width-container { padding: 16px; }
            .bottom-bar { padding: 12px; }
            .bottom-bar-content { flex-direction: column; gap: 12px; align-items: stretch; }
            h2 { font-size: 1.4rem; }
            h3 { font-size: 1.1rem; }
            label { font-size: 0.85rem; }
            button { font-size: 0.9rem; padding: 8px 12px; }
            input, select { font-size: 0.9rem; padding: 8px; }
            .stake-amount-input { width: 100%; }
            .action-cell { flex-direction: column; gap: 8px; align-items: stretch; }
            .pool-card-details { grid-template-columns: 1fr; }
            .pool-card { padding: 12px; }
            .pool-card-header h3 { font-size: 1.1rem; }
            .pool-card-header span { font-size: 0.9rem; }
            .breakeven-formula { font-size: 0.595rem; }
        }

        @media (max-width: 480px) {
            body { padding: 12px; -webkit-text-size-adjust: 100%; }
            .flex-container { padding: 0 8px; }
            .full-width-container { padding: 12px; }
            h2 { font-size: 1.3rem; }
            h3 { font-size: 1rem; }
            button { padding: 8px 10px; font-size: 0.85rem; min-height: 44px; }
            input, select { padding: 8px; font-size: 0.85rem; }
            .stake-amount-input { width: 100%; }
            .pool-card-details { font-size: 0.8rem; }
            .breakeven-formula { font-size: 0.56rem; }
        }

        @media (min-width: 769px) {
            .full-width-container { min-width: 45%; }
        }

        @media (min-width: 992px) {
            .flex-container { padding: 0 24px; }
            h2 { font-size: 1.9rem; }
            h3 { font-size: 1.3rem; }
            button { padding: 12px 20px; }
        }
    </style>
</head>
<body>
    <div class="flex-container">
        <div class="full-width-container">
            <h2>Create Dividend Pool</h2>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="pool-token">Token Address</label>
                    <span class="help-icon" onclick="toggleHelpNote('pool-token-help')">?</span>
                </div>
                <input id="pool-token" type="text" placeholder="e.g., 0xTokenAddress" aria-label="Token Address" />
                <div id="pool-token-help" class="help-note">The token address that the dividend pool is built around.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="hard-lock-duration">Hard Lock Duration (days)</label>
                    <span class="help-icon" onclick="toggleHelpNote('hard-lock-duration-help')">?</span>
                </div>
                <input id="hard-lock-duration" type="text" placeholder="e.g., 30" inputmode="numeric" pattern="[0-9]*" aria-label="Hard Lock Duration" />
                <div id="hard-lock-duration-help" class="help-note">Amount of days staked tokens must remain locked in the contract, unable to be withdrawn.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="initial-penalty-percent">Initial Penalty Percent (%)</label>
                    <span class="help-icon" onclick="toggleHelpNote('initial-penalty-percent-help')">?</span>
                </div>
                <input id="initial-penalty-percent" type="text" placeholder="e.g., 10" inputmode="numeric" pattern="[0-9]*" aria-label="Initial Penalty Percent" />
                <div id="initial-penalty-percent-help" class="help-note">Percentage penalty for early withdrawal at the end of the hard lock period.</div>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label for="penalty-decay-percent">Penalty Decay Percent Per Day (%)</label>
                    <span class="help-icon" onclick="toggleHelpNote('penalty-decay-percent-help')">?</span>
                </div>
                <input id="penalty-decay-percent" type="text" placeholder="e.g., 1" inputmode="decimal" aria-label="Penalty Decay Percent" />
                <div id="penalty-decay-percent-help" class="help-note">Daily reduction in penalty percentage for early withdrawal.</div>
            </div>
            <div class="launch-pool-container">
                <button id="launch-pool-button" onclick="createPool()" aria-label="Create Pool">Create Pool</button>
            </div>
            <div class="field-container">
                <div class="label-with-help">
                    <label>Breakeven Days Calculation</label>
                    <span class="help-icon" onclick="toggleHelpNote('breakeven-help')">?</span>
                </div>
                <div style="background: rgba(17, 24, 39, 0.8); padding: 10px; border-radius: 8px; border: 1px solid rgba(165, 180, 252, 0.2);">
                    <p class="breakeven-formula" style="color: #D1D5DB;">Breakeven Days = Hard Lock Duration + (Initial Penalty % / Penalty Decay % per Day)</p>
                    <p style="font-size: 0.9rem; color: #F9FAFB;">
                        <span id="breakeven-formula">Breakeven Days = </span>
                        <input style="width: 60px; display: inline-block; margin: 0 5px;" id="breakeven-hard-lock" type="text" placeholder="H" value="" inputmode="numeric" pattern="[0-9]*" oninput="updateBreakevenFormula()" />
                        <span> + ( </span>
                        <input style="width: 60px; display: inline-block; margin: 0 5px;" id="breakeven-initial-penalty" type="text" placeholder="P" value="" inputmode="numeric" pattern="[0-9]*" oninput="updateBreakevenFormula()" />
                        <span> / </span>
                        <input style="width: 60px; display: inline-block; margin: 0 5px;" id="breakeven-decay" type="text" placeholder="D" value="" inputmode="decimal" oninput="updateBreakevenFormula()" />
                        <span> ) = </span>
                        <span id="breakeven-result">0</span>
                        <span> days</span>
                    </p>
                    <div id="breakeven-help" class="help-note">Number of days until the withdrawal penalty reaches zero.</div>
                </div>
            </div>
        </div>

        <div class="full-width-container">
            <h2>All Dividend Pools</h2>
            <div id="pool-list">
                <div id="pool-card-container"></div>
            </div>
        </div>
    </div>

    <div class="bottom-bar">
        <div class="bottom-bar-content">
            <button id="connect-wallet-button" onclick="connectWallet()" aria-label="Connect Wallet">Connect Wallet</button>
            <select id="wallet-selector" onchange="selectWallet(this.value)" aria-label="Select Wallet">
                <option value="">-- Select Wallet --</option>
            </select>
            <div id="status-log"></div>
        </div>
    </div>

    <script>
        const FACTORY_ADDRESS = "0x1e9fad843af0e7bc66095f9663b6cbb2992f3d91";
        const RPC_ENDPOINTS = [
            'https://mainnet.infura.io/v3/cf2916fb6dbc47ae824d6f36db817b73'
        ];
        let currentRpcIndex = 0;

        const addressRegex = /^0x[a-fA-F0-9]{40}$/;
        const integerRegex = /^[0-9]+$/;
        const decimalRegex = /^[0-9]+(\.[0-9]{0,18})?$/;
        const privateKeyRegex = /^0x[a-fA-F0-9]{64}$/;
        const txHashRegex = /0x[a-fA-F0-9]{64}/g;

        function validateAddress(address) {
            if (!address || typeof address !== 'string') return false;
            return addressRegex.test(address.trim());
        }

        function validatePrivateKey(key) {
            if (!key || typeof key !== 'string') return false;
            return privateKeyRegex.test(key.trim());
        }

        function validateInteger(input, min = 0, max = Number.MAX_SAFE_INTEGER) {
            if (!input || typeof input !== 'string') return null;
            const trimmed = input.trim();
            if (!integerRegex.test(trimmed)) return null;
            try {
                const num = BigInt(trimmed);
                if (num < BigInt(min) || num > BigInt(max)) return null;
                return num.toString();
            } catch (e) {
                return null;
            }
        }

        function validateDecimal(input, min = 0, max = 1e18, maxDecimals = 18) {
            if (!input || typeof input !== 'string') return null;
            const trimmed = input.trim();
            if (!decimalRegex.test(trimmed)) return null;
            const [integerPart, decimalPart = ''] = trimmed.split('.');
            if (decimalPart.length > maxDecimals) return null;
            try {
                const num = parseFloat(trimmed);
                if (isNaN(num) || num < min || num > max) return null;
                const formatted = num.toFixed(maxDecimals).replace(/\.?0+$/, '');
                ethers.BigNumber.from(ethers.utils.parseUnits(formatted, maxDecimals));
                return formatted;
            } catch (e) {
                return null;
            }
        }

        const factoryAbi = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "hardLockDuration",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "initialPenaltyPercent",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "penaltyDecayPercentPerDay",
                        "type": "uint256"
                    }
                ],
                "name": "createPool",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "poolAddr",
                        "type": "address"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "DecayTooFast",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "InvalidToken",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "NotERC20",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "ParamOutOfRange",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "PoolExists",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "reason",
                        "type": "string"
                    }
                ],
                "name": "PoolInitializationFailed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "poolAddress",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "hardLockDuration",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "initialPenaltyPercent",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "penaltyDecayPercentPerDay",
                        "type": "uint256"
                    }
                ],
                "name": "StakingPoolCreated",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "getAllPools",
                "outputs": [
                    {
                        "internalType": "address[]",
                        "name": "",
                        "type": "address[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    }
                ],
                "name": "getPool",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "pools",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        const poolAbi = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_factory",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "_token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_hardLockDuration",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_initialPenaltyPercent",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_penaltyDecayPercentPerDay",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [],
                "name": "InsufficientBalance",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "InvalidAmount",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "InvalidToken",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "Locked",
                "type": "error"
            },
            {
                "inputs": [],
                "name": "NoStake",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "OwnableInvalidOwner",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "OwnableUnauthorizedAccount",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "token",
                        "type": "address"
                    }
                ],
                "name": "SafeERC20FailedOperation",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "oldRecip",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "newRecip",
                        "type": "address"
                    }
                ],
                "name": "FeeRecipientUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "previousOwner",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "OwnershipTransferred",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "user",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "rewardTok",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amt",
                        "type": "uint256"
                    }
                ],
                "name": "RewardsClaimed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "user",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amt",
                        "type": "uint256"
                    }
                ],
                "name": "Staked",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "user",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amt",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "penalty",
                        "type": "uint256"
                    }
                ],
                "name": "Unstaked",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "FEE_DENOMINATOR",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "FEE_PERCENT",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "HARD_LOCK_DURATION",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "INITIAL_PENALTY_PERCENT",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "MIN_STAKE",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "PENALTY_DECAY_PERCENT_PER_DAY",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "rewardToken",
                        "type": "address"
                    }
                ],
                "name": "claimReward",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address[]",
                        "name": "rewardTokens_",
                        "type": "address[]"
                    }
                ],
                "name": "claimRewards",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "factoryAddress",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "feeRecipient",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "renounceOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "rewardPerTokenStored",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "rewardTokens",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "rewards",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "stake",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "stakes",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "stakeTimestamp",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "token",
                "outputs": [
                    {
                        "internalType": "contract IERC20",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "tokenBalance",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalStaked",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "transferOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "unstake",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "newRecipient",
                        "type": "address"
                    }
                ],
                "name": "updateFeeRecipient",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "userRewardPerTokenPaid",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            }
        ];

        const erc20Abi = [
            {
                "constant": true,
                "inputs": [],
                "name": "name",
                "outputs": [
                    { "name": "", "type": "string" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [
                    { "name": "", "type": "string" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    { "name": "", "type": "uint8" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    { "name": "_owner", "type": "address" }
                ],
                "name": "balanceOf",
                "outputs": [
                    { "name": "balance", "type": "uint256" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    { "name": "_to", "type": "address" },
                    { "name": "_value", "type": "uint256" }
                ],
                "name": "transfer",
                "outputs": [
                    { "name": "success", "type": "bool" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    { "name": "_spender", "type": "address" },
                    { "name": "_value", "type": "uint256" }
                ],
                "name": "approve",
                "outputs": [
                    { "name": "success", "type": "bool" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        function getWeb3() {
            return new Web3(RPC_ENDPOINTS[currentRpcIndex]);
        }

        let web3 = getWeb3();
        let userAccount = null;
        let signer = null;
        let selectedWallet = null;
        let wallets = [];

        async function switchRpc() {
            currentRpcIndex = (currentRpcIndex + 1) % RPC_ENDPOINTS.length;
            web3 = getWeb3();
            console.log(`Switched to RPC: ${RPC_ENDPOINTS[currentRpcIndex]}`);
        }

        async function checkNetwork() {
            try {
                const chainId = await web3.eth.getChainId();
                if (chainId !== 1) {
                    throw new Error(`Incorrect network ID: ${chainId}. Expected Ethereum Mainnet (chainId: 1).`);
                }
                console.log("Connected to Ethereum Mainnet (chainId: 1)");
            } catch (error) {
                console.error(`Network check failed: ${error.message}`);
                throw error;
            }
        }

        async function withRetry(fn, maxRetries = 3, delayMs = 1000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await checkNetwork();
                    return await fn();
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    console.error(`Attempt ${attempt} failed: ${error.message}. Retrying with RPC ${RPC_ENDPOINTS[currentRpcIndex]}...`);
                    await switchRpc();
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
        }

        function loadStatusLog() {
            const savedLogs = JSON.parse(localStorage.getItem('statusLogs') || '[]');
            const statusLog = document.getElementById('status-log');
            statusLog.innerHTML = '';
            savedLogs.forEach(log => {
                const entry = document.createElement('div');
                entry.className = `status-entry ${log.type}`;
                let message = log.message;
                if (log.type === 'success') {
                    message = message.replace(txHashRegex, hash => `<a href="https://etherscan.io/tx/${hash}" target="_blank" rel="noopener noreferrer">${hash.slice(0, 6)}...${hash.slice(-4)}</a>`);
                }
                entry.innerHTML = `
                    <span class="status-timestamp">[${log.timestamp}]</span>
                    <span>${log.emoji} ${message}</span>
                `;
                statusLog.appendChild(entry);
            });
            statusLog.scrollTop = statusLog.scrollHeight;
        }

        function logStatus(message, type = 'pending') {
            console.log(`${type.toUpperCase()}: ${message}`);
            const statusLog = document.getElementById('status-log');
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const emoji = type === 'success' ? '' : type === 'error' ? '' : '';
            let displayMessage = message;
            if (type === 'success') {
                displayMessage = message.replace(txHashRegex, hash => `<a href="https://etherscan.io/tx/${hash}" target="_blank" rel="noopener noreferrer">${hash.slice(0, 6)}...${hash.slice(-4)}</a>`);
            }
            const entry = document.createElement('div');
            entry.className = `status-entry ${type}`;
            entry.innerHTML = `
                <span class="status-timestamp">[${timestamp}]</span>
                <span>${emoji} ${displayMessage}</span>
            `;
            statusLog.appendChild(entry);
            statusLog.scrollTop = statusLog.scrollHeight;

            const savedLogs = JSON.parse(localStorage.getItem('statusLogs') || '[]');
            savedLogs.push({ timestamp, message, type, emoji });
            if (savedLogs.length > 50) savedLogs.shift();
            localStorage.setItem('statusLogs', JSON.stringify(savedLogs));
        }

        function showSpinner(button) {
            button.disabled = true;
            const originalText = button.innerHTML;
            button.innerHTML = '<span class="spinner"></span>';
            return originalText;
        }

        function hideSpinner(button, originalText) {
            button.disabled = false;
            button.innerHTML = originalText;
        }

        function toggleHelpNote(noteId) {
            const note = document.getElementById(noteId);
            if (note.classList.contains('active')) {
                note.classList.remove('active');
            } else {
                document.querySelectorAll('.help-note.active').forEach(n => n.classList.remove('active'));
                note.classList.add('active');
            }
        }

        async function connectWallet() {
            const button = document.getElementById('connect-wallet-button');
            const originalText = showSpinner(button);
            logStatus("Connecting wallet...");
            try {
                if (!window.ethereum) {
                    logStatus("Please install MetaMask to use this feature.", 'error');
                    return;
                }
                web3 = new Web3(window.ethereum);
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();

                await window.ethereum.request({ method: "eth_requestAccounts" });
                userAccount = (await web3.eth.getAccounts())[0];
                logStatus(`Wallet connected successfully: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`, 'success');

                await initializeWallets();
                await refreshPools();
            } catch (error) {
                console.error(`Wallet connection error: ${error.message}`);
                logStatus(`Failed to connect wallet: ${error.message}`, 'error');
                signer = null;
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function initializeWallets() {
            try {
                console.log("Initializing wallets...");
                wallets = JSON.parse(localStorage.getItem('wallets') || '[]');

                // Add MetaMask wallet if available
                if (window.ethereum && userAccount) {
                    const metamaskWallet = { address: userAccount, type: 'MetaMask', isMetaMask: true };
                    if (!wallets.some(w => w.address.toLowerCase() === metamaskWallet.address.toLowerCase() && w.type === 'MetaMask')) {
                        wallets = wallets.filter(w => w.type !== 'MetaMask');
                        wallets.push(metamaskWallet);
                    }
                }

                // Validate and update MoneyFund wallets
                wallets = wallets.map(wallet => {
                    if (wallet.type === 'MoneyFund' && wallet.privateKey) {
                        if (!validatePrivateKey(wallet.privateKey)) {
                            console.error(`Invalid private key for MoneyFund wallet: ${wallet.address}`);
                            return null;
                        }
                        return { ...wallet, isMetaMask: false };
                    }
                    return wallet;
                }).filter(wallet => wallet !== null);

                localStorage.setItem('wallets', JSON.stringify(wallets));

                const walletSelector = document.getElementById('wallet-selector');
                walletSelector.innerHTML = '<option value="">-- Select Wallet --</option>';
                wallets.forEach((wallet, index) => {
                    if (wallet.address && validateAddress(wallet.address)) {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${wallet.type}: ${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
                        walletSelector.appendChild(option);
                    } else {
                        console.error(`Invalid wallet at index ${index}: missing or invalid address`);
                    }
                });

                const selectedIndex = parseInt(localStorage.getItem('selectedWalletIndex'));
                console.log(`Stored selectedWalletIndex: ${selectedIndex}`);

                if (wallets.length > 0 && !isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < wallets.length) {
                    selectedWallet = wallets[selectedIndex];
                    userAccount = selectedWallet.address;
                    walletSelector.value = selectedIndex;
                    if (selectedWallet.isMetaMask && window.ethereum) {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (!accounts || accounts.length === 0 || accounts[0].toLowerCase() !== selectedWallet.address.toLowerCase()) {
                            console.log("MetaMask selected but not connected. Requesting connection.");
                            await connectWallet();
                        } else {
                            const provider = new ethers.providers.Web3Provider(window.ethereum);
                            signer = provider.getSigner();
                        }
                    } else {
                        web3 = getWeb3();
                        signer = null; // Defer signer initialization for MoneyFund wallets
                    }
                    console.log(`Selected wallet: ${userAccount}`);
                    await refreshPools();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    walletSelector.value = "";
                    console.log("No valid wallet selected");
                }
            } catch (error) {
                console.error(`Wallet initialization error: ${error.message}`);
                logStatus(`Wallet initialization failed: ${error.message}`, 'error');
                signer = null;
            }
        }

        function selectWallet(index) {
            try {
                const idx = parseInt(index);
                if (idx >= 0 && idx < wallets.length && wallets[idx].address && validateAddress(wallets[idx].address)) {
                    selectedWallet = wallets[idx];
                    localStorage.setItem('selectedWalletIndex', idx);
                    userAccount = selectedWallet.address;

                    if (selectedWallet.isMetaMask) {
                        if (window.ethereum) {
                            connectWallet();
                        } else {
                            console.error("MetaMask extension not detected.");
                            logStatus("MetaMask extension not detected.", 'error');
                            selectedWallet = null;
                            userAccount = null;
                            signer = null;
                            document.getElementById('wallet-selector').value = "";
                            localStorage.removeItem('selectedWalletIndex');
                        }
                    } else {
                        web3 = getWeb3();
                        signer = null; // Defer signer initialization for MoneyFund wallets
                        if (selectedWallet.type === 'MoneyFund' && !validatePrivateKey(selectedWallet.privateKey)) {
                            throw new Error(`Invalid private key for MoneyFund wallet: ${selectedWallet.address}`);
                        }
                    }
                    console.log(`Selected wallet: ${userAccount}`);
                    refreshPools();
                } else {
                    selectedWallet = null;
                    userAccount = null;
                    signer = null;
                    localStorage.removeItem('selectedWalletIndex');
                    document.getElementById('wallet-selector').value = "";
                    web3 = getWeb3();
                    console.log("Invalid wallet selection");
                }
            } catch (error) {
                console.error(`Wallet selection error: ${error.message}`);
                logStatus(`Failed to select wallet: ${error.message}`, 'error');
                signer = null;
            }
        }

        async function getGasPrice() {
            return await withRetry(async () => {
                const baseGasPrice = BigInt(await web3.eth.getGasPrice());
                const baseGasPriceGwei = Number(web3.utils.fromWei(baseGasPrice.toString(), 'gwei'));
                const adjustedGasPriceGwei = Math.max(1, baseGasPriceGwei * 1.25);
                return web3.utils.toWei(adjustedGasPriceGwei.toFixed(0), 'gwei');
            });
        }

        async function checkWalletBalance(address, gasLimit, gasPrice) {
            try {
                const balance = await withRetry(() => web3.eth.getBalance(address));
                const requiredGas = BigInt(gasLimit) * BigInt(gasPrice);
                if (BigInt(balance) < requiredGas) {
                    throw new Error(
                        `Insufficient ETH balance: need ${web3.utils.fromWei(requiredGas.toString(), 'ether')} ETH, have ${web3.utils.fromWei(balance, 'ether')} ETH`
                    );
                }
                return true;
            } catch (error) {
                console.error(`Wallet balance check failed: ${error.message}`);
                throw error;
            }
        }

        async function createPool() {
            const button = document.getElementById('launch-pool-button');
            const originalText = showSpinner(button);
            logStatus("Initiating dividend pool creation...");
            try {
                console.log("createPool function triggered");
                if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                    console.error("No wallet selected or connected");
                    logStatus("Please connect and select a wallet first.", 'error');
                    return;
                }
                console.log(`Wallet connected: ${userAccount}`);

                const token = document.getElementById("pool-token").value;
                const hardLockDuration = document.getElementById("hard-lock-duration").value;
                const initialPenaltyPercent = document.getElementById("initial-penalty-percent").value;
                const penaltyDecayPercent = document.getElementById("penalty-decay-percent").value;

                console.log(`Inputs: token=${token}, hardLockDuration=${hardLockDuration}, initialPenaltyPercent=${initialPenaltyPercent}, penaltyDecayPercent=${penaltyDecayPercent}`);

                if (!token || !hardLockDuration || !initialPenaltyPercent || !penaltyDecayPercent) {
                    console.error("Missing input fields");
                    logStatus("Please fill in all fields.", 'error');
                    return;
                }

                if (!validateAddress(token)) {
                    console.error(`Invalid token address: ${token}`);
                    logStatus(`Invalid token address: ${token}`, 'error');
                    return;
                }

                const hardLockDurationNum = validateInteger(hardLockDuration, 0);
                if (!hardLockDurationNum) {
                    console.error("Invalid hard lock duration");
                    logStatus("Hard lock duration must be a non-negative integer.", 'error');
                    return;
                }

                const initialPenaltyPercentNum = validateInteger(initialPenaltyPercent, 0, 100);
                if (!initialPenaltyPercentNum) {
                    console.error("Invalid initial penalty percent");
                    logStatus("Initial penalty percent must be an integer between 0 and 100.", 'error');
                    return;
                }

                const penaltyDecayPercentNum = validateDecimal(penaltyDecayPercent, 0, 100, 4);
                if (!penaltyDecayPercentNum) {
                    console.error("Invalid penalty decay percent");
                    logStatus("Penalty decay percent must be a number between 0 and 100 with up to 4 decimal places.", 'error');
                    return;
                }

                const hardLockSeconds = BigInt(hardLockDurationNum) * BigInt(86400);
                const initialPenaltyBps = BigInt(initialPenaltyPercentNum) * BigInt(100);
                const penaltyDecayBps = ethers.utils.parseUnits(penaltyDecayPercentNum, 2);

                logStatus("Preparing to create dividend pool...");
                console.log("Creating contract instance");
                const factory = new web3.eth.Contract(factoryAbi, FACTORY_ADDRESS);

                let gasEstimate;
                try {
                    console.log("Estimating gas");
                    gasEstimate = await withRetry(() =>
                        factory.methods.createPool(
                            token,
                            hardLockSeconds.toString(),
                            initialPenaltyBps.toString(),
                            penaltyDecayBps.toString()
                        ).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Estimated gas limit: ${gasEstimate}`);
                } catch (err) {
                    gasEstimate = 1500000;
                    console.error(`Gas estimation failed, using default ${gasEstimate}: ${err.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                logStatus(selectedWallet.isMetaMask ? "Creating pool... Please confirm in MetaMask." : "Creating pool... Signing with MoneyFund wallet.");
                console.log("Initiating transaction");

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    console.log("Using MetaMask for transaction");
                    const factoryEthers = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);
                    tx = await factoryEthers.createPool(
                        token,
                        hardLockSeconds.toString(),
                        initialPenaltyBps.toString(),
                        penaltyDecayBps,
                        {
                            gasLimit: gasEstimate,
                            gasPrice: gasPrice
                        }
                    );
                    console.log("Waiting for transaction confirmation");
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    console.log("Using MoneyFund wallet for transaction");
                    const txData = factory.methods.createPool(
                        token,
                        hardLockSeconds.toString(),
                        initialPenaltyBps.toString(),
                        penaltyDecayBps.toString()
                    ).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: FACTORY_ADDRESS,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                    console.log("Transaction sent and confirmed");
                }

                const poolAddress = tx.logs.find(log => {
                    try {
                        const iface = new ethers.utils.Interface(factoryAbi);
                        const parsedLog = iface.parseLog(log);
                        return parsedLog.name === 'StakingPoolCreated';
                    } catch (e) {
                        return false;
                    }
                })?.args?.poolAddress;

                if (!validateAddress(poolAddress)) {
                    throw new Error("Invalid pool address received.");
                }

                logStatus(`Dividend pool for token ${token.slice(0, 6)}...${token.slice(-4)} created at: ${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}! Transaction: ${tx.transactionHash || tx.hash}`, 'success');
                console.log(`Dividend pool created at: ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                await refreshPools();
            } catch (err) {
                console.error(`Pool creation failed: ${err.message}`);
                logStatus(`Failed to create dividend pool: ${err.message}`, 'error');
                alert(`Failed to create dividend pool: ${err.message}. Check the console for details.`);
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function stakeTokens(poolAddress, amount) {
            console.log(`Attempting to stake ${amount} tokens in pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            const validatedAmount = validateDecimal(amount, 0.00000001, 1e18);
            if (!validatedAmount) {
                console.error(`Invalid stake amount: ${amount}`);
                return { error: "Please enter a valid positive amount with up to 18 decimals." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const tokenAddress = await withRetry(() => pool.methods.token().call());
                if (!validateAddress(tokenAddress)) {
                    throw new Error("Invalid token address retrieved from pool.");
                }

                const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
                const decimals = await withRetry(() => tokenContract.methods.decimals().call());
                if (typeof decimals !== 'string' && typeof decimals !== 'number') {
                    throw new Error("Invalid token decimals.");
                }
                const maxDecimals = Math.min(Number(decimals), 18);
                const reValidatedAmount = validateDecimal(validatedAmount, 0.00000001, 1e18, maxDecimals);
                if (!reValidatedAmount) {
                    throw new Error(`Amount exceeds token's decimal precision (${maxDecimals} decimals).`);
                }

                const amountWei = ethers.utils.parseUnits(reValidatedAmount, decimals);
                const amountWeiStr = amountWei.toString();

                const tokenBalance = await withRetry(() => tokenContract.methods.balanceOf(userAccount).call());
                if (ethers.BigNumber.from(tokenBalance).lt(amountWei)) {
                    throw new Error(
                        `Insufficient token balance: need ${reValidatedAmount} tokens, have ${ethers.utils.formatUnits(tokenBalance, decimals)} tokens`
                    );
                }

                let approveGasEstimate;
                try {
                    approveGasEstimate = await withRetry(() =>
                        tokenContract.methods.approve(poolAddress, amountWeiStr).estimateGas({ from: userAccount })
                    );
                    approveGasEstimate = Math.ceil(Number(approveGasEstimate) * 1.2);
                } catch (error) {
                    approveGasEstimate = 100000;
                    console.error(`Approve gas estimation failed, using default ${approveGasEstimate}: ${error.message}`);
                }

                let stakeGasEstimate;
                try {
                    stakeGasEstimate = await withRetry(() =>
                        pool.methods.stake(amountWeiStr).estimateGas({ from: userAccount })
                    );
                    stakeGasEstimate = Math.ceil(Number(stakeGasEstimate) * 1.2);
                    console.log(`Stake gas limit: ${stakeGasEstimate}`);
                } catch (error) {
                    stakeGasEstimate = 1500000;
                    console.error(`Stake gas estimation failed, using default ${stakeGasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, approveGasEstimate + stakeGasEstimate, gasPrice);

                let approveTx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const tokenEthers = new ethers.Contract(tokenAddress, erc20Abi, signer);
                    approveTx = await tokenEthers.approve(poolAddress, amountWei, {
                        gasLimit: approveGasEstimate,
                        gasPrice: gasPrice
                    });
                    await approveTx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const approveTxData = tokenContract.methods.approve(poolAddress, amountWeiStr).encodeABI();
                    const approveNonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const approveTransactionObject = {
                        from: userAccount,
                        to: tokenAddress,
                        data: approveTxData,
                        gas: approveGasEstimate,
                        gasPrice: gasPrice,
                        nonce: approveNonce
                    };
                    const signedApproveTx = await web3.eth.accounts.signTransaction(approveTransactionObject, selectedWallet.privateKey);
                    approveTx = await withRetry(() => web3.eth.sendSignedTransaction(signedApproveTx.rawTransaction));
                }

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.stake(amountWei, {
                        gasLimit: stakeGasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const txData = pool.methods.stake(amountWeiStr).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: stakeGasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Staked ${reValidatedAmount} tokens in pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Staked ${reValidatedAmount} tokens successfully! Transaction: ${tx.transactionHash || tx.hash}` };
            } catch (error) {
                console.error(`Stake failed: ${error.message}`);
                return { error: `Stake failed: ${error.message}` };
            }
        }

        async function unstakeTokens(poolAddress) {
            console.log(`Attempting to unstake tokens from pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const stakeInfo = await withRetry(() => pool.methods.stakes(userAccount).call());
                if (stakeInfo.amount === '0') {
                    throw new Error("No staked tokens to unstake.");
                }

                let gasEstimate;
                try {
                    gasEstimate = await withRetry(() =>
                        pool.methods.unstake().estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Unstake gas limit: ${gasEstimate}`);
                } catch (error) {
                    gasEstimate = 1500000;
                    console.error(`Unstake gas estimation failed, using default ${gasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.unstake({
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                    const txData = pool.methods.unstake().encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Unstaked tokens from pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Unstaked tokens successfully! Transaction: ${tx.transactionHash || tx.hash}` };
            } catch (error) {
                console.error(`Unstake failed: ${error.message}`);
                return { error: `Unstake failed: ${error.message}` };
            }
        }

        async function claimRewards(poolAddress, rewardTokens) {
            console.log(`Attempting to claim rewards from pool ${poolAddress}`);

            if (!selectedWallet || !userAccount || !validateAddress(userAccount)) {
                console.error("Please select a wallet.");
                return { error: "Please select a wallet." };
            }

            if (!validateAddress(poolAddress)) {
                console.error(`Invalid pool address: ${poolAddress}`);
                return { error: "Invalid pool address." };
            }

            if (!rewardTokens.every(validateAddress)) {
                console.error("Invalid reward token addresses");
                return { error: "Invalid reward token addresses." };
            }

            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                let gasEstimate;
                try {
                    gasEstimate = await withRetry(() =>
                        pool.methods.claimRewards(rewardTokens).estimateGas({ from: userAccount })
                    );
                    gasEstimate = Math.ceil(Number(gasEstimate) * 1.2);
                    console.log(`Claim rewards gas limit: ${gasEstimate}`);
                } catch (error) {
                    gasEstimate = 1500000;
                    console.error(`Claim rewards gas estimation failed, using default ${gasEstimate}: ${error.message}`);
                }

                const gasPrice = await getGasPrice();
                console.log(`Gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} Gwei`);

                await checkWalletBalance(userAccount, gasEstimate, gasPrice);

                let tx;
                if (selectedWallet.isMetaMask) {
                    if (!signer) {
                        throw new Error("MetaMask signer not initialized.");
                    }
                    const poolEthers = new ethers.Contract(poolAddress, poolAbi, signer);
                    tx = await poolEthers.claimRewards(rewardTokens, {
                        gasLimit: gasEstimate,
                        gasPrice: gasPrice
                    });
                    await tx.wait();
                } else {
                    if (!selectedWallet.privateKey || !validatePrivateKey(selectedWallet.privateKey)) {
                        throw new Error("MoneyFund wallet private key missing or invalid.");
                    }
                                        const txData = pool.methods.claimRewards(rewardTokens).encodeABI();
                    const nonce = await withRetry(() => web3.eth.getTransactionCount(userAccount, 'latest'));
                    const transactionObject = {
                        from: userAccount,
                        to: poolAddress,
                        data: txData,
                        gas: gasEstimate,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    const signedTx = await web3.eth.accounts.signTransaction(transactionObject, selectedWallet.privateKey);
                    tx = await withRetry(() => web3.eth.sendSignedTransaction(signedTx.rawTransaction));
                }

                console.log(`Claimed rewards from pool ${poolAddress}: ${tx.transactionHash || tx.hash}`);
                return { success: `Claimed rewards successfully! Transaction: ${tx.transactionHash || tx.hash}` };
            } catch (error) {
                console.error(`Claim rewards failed: ${error.message}`);
                return { error: `Claim rewards failed: ${error.message}` };
            }
        }

        async function refreshPools() {
            console.log("Refreshing pools...");
            try {
                const poolContainer = document.getElementById('pool-card-container');
                poolContainer.innerHTML = '';

                const factory = new web3.eth.Contract(factoryAbi, FACTORY_ADDRESS);
                const poolAddresses = await withRetry(() => factory.methods.getAllPools().call());

                if (!poolAddresses.length || poolAddresses.every(addr => addr === '0x0000000000000000000000000000000000000000')) {
                    poolContainer.innerHTML = '<p style="text-align: center; color: #D1D5DB;">No pools found. Create a pool to get started.</p>';
                    return;
                }

                for (const poolAddress of poolAddresses.filter(validateAddress)) {
                    try {
                        const pool = new web3.eth.Contract(poolAbi, poolAddress);
                        const tokenAddress = await withRetry(() => pool.methods.token().call());
                        if (!validateAddress(tokenAddress)) {
                            console.error(`Invalid token address for pool ${poolAddress}`);
                            continue;
                        }

                        const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);

                        const [name, symbol, decimals, hardLockDuration, initialPenaltyPercent, penaltyDecayPercent, totalStaked, userStake] = await Promise.all([
                            withRetry(() => tokenContract.methods.name().call()).catch(() => 'Unknown'),
                            withRetry(() => tokenContract.methods.symbol().call()).catch(() => '???'),
                            withRetry(() => tokenContract.methods.decimals().call()).catch(() => '18'),
                            withRetry(() => pool.methods.HARD_LOCK_DURATION().call()),
                            withRetry(() => pool.methods.INITIAL_PENALTY_PERCENT().call()),
                            withRetry(() => pool.methods.PENALTY_DECAY_PERCENT_PER_DAY().call()),
                            withRetry(() => pool.methods.totalStaked().call()),
                            userAccount && validateAddress(userAccount) ? withRetry(() => pool.methods.stakes(userAccount).call()) : { amount: '0', stakeTimestamp: '0' }
                        ]);

                        const poolCard = document.createElement('div');
                        poolCard.className = 'pool-card';
                        poolCard.innerHTML = `
                            <div class="pool-card-header">
                                <h3>${symbol} Pool</h3>
                                <span>${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}</span>
                            </div>
                            <div class="pool-card-details">
                                <div>
                                    <label>Token Name</label>
                                    <span>${name}</span>
                                </div>
                                <div>
                                    <label>Token Address</label>
                                    <span>${tokenAddress.slice(0, 6)}...${tokenAddress.slice(-4)}</span>
                                </div>
                                <div>
                                    <label>Hard Lock</label>
                                    <span>${(BigInt(hardLockDuration) / BigInt(86400)).toString()} days</span>
                                </div>
                                <div>
                                    <label>Initial Penalty</label>
                                    <span>${(BigInt(initialPenaltyPercent) / BigInt(100)).toString()}%</span>
                                </div>
                                <div>
                                    <label>Penalty Decay/Day</label>
                                    <span>${ethers.utils.formatUnits(penaltyDecayPercent, 2)}%</span>
                                </div>
                                <div>
                                    <label>Total Staked</label>
                                    <span>${ethers.utils.formatUnits(totalStaked, decimals)} ${symbol}</span>
                                </div>
                                <div>
                                    <label>Your Stake</label>
                                    <span>${ethers.utils.formatUnits(userStake.amount, decimals)} ${symbol}</span>
                                </div>
                            </div>
                            <div class="pool-card-actions">
                                <div class="action-cell">
                                    <input type="text" class="stake-amount-input" id="stake-amount-${poolAddress}" placeholder="Amount to stake" inputmode="decimal" />
                                    <button class="stake-button" onclick="handleStake('${poolAddress}')">Stake</button>
                                </div>
                                <div class="action-cell">
                                    <button class="unstake-button" onclick="handleUnstake('${poolAddress}')">Unstake</button>
                                </div>
                                <div class="action-cell">
                                    <button class="claim-rewards-button" onclick="handleClaimRewards('${poolAddress}')">Claim Rewards</button>
                                </div>
                                <div class="action-cell">
                                    <button class="copy-button" onclick="copyToClipboard('${poolAddress}')">Copy Address</button>
                                </div>
                            </div>
                        `;
                        poolContainer.appendChild(poolCard);
                    } catch (err) {
                        console.error(`Error loading pool ${poolAddress}: ${err.message}`);
                    }
                }
            } catch (err) {
                console.error(`Failed to refresh pools: ${err.message}`);
                logStatus(`Failed to refresh pools: ${err.message}`, 'error');
                poolContainer.innerHTML = '<p style="text-align: center; color: #D1D5DB;">Failed to load pools. Please try again later.</p>';
            }
        }

        async function handleStake(poolAddress) {
            const button = document.querySelector(`#stake-amount-${poolAddress}`).parentElement.querySelector('.stake-button');
            const originalText = showSpinner(button);
            const amount = document.getElementById(`stake-amount-${poolAddress}`).value;
            logStatus(`Initiating stake of ${amount} tokens in pool ${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}...`);
            try {
                const result = await stakeTokens(poolAddress, amount);
                if (result.error) {
                    logStatus(result.error, 'error');
                    alert(result.error);
                } else {
                    logStatus(result.success, 'success');
                    await refreshPools();
                }
            } catch (err) {
                console.error(`Stake failed: ${err.message}`);
                logStatus(`Failed to stake tokens: ${err.message}`, 'error');
                alert(`Failed to stake tokens: ${err.message}`);
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function handleUnstake(poolAddress) {
            const button = document.querySelector(`.unstake-button[onclick="handleUnstake('${poolAddress}')"]`);
            const originalText = showSpinner(button);
            logStatus(`Initiating unstake from pool ${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}...`);
            try {
                const result = await unstakeTokens(poolAddress);
                if (result.error) {
                    logStatus(result.error, 'error');
                    alert(result.error);
                } else {
                    logStatus(result.success, 'success');
                    await refreshPools();
                }
            } catch (err) {
                console.error(`Unstake failed: ${err.message}`);
                logStatus(`Failed to unstake tokens: ${err.message}`, 'error');
                alert(`Failed to unstake tokens: ${err.message}`);
            } finally {
                hideSpinner(button, originalText);
            }
        }

        async function handleClaimRewards(poolAddress) {
            const button = document.querySelector(`.claim-rewards-button[onclick="handleClaimRewards('${poolAddress}')"]`);
            const originalText = showSpinner(button);
            logStatus(`Initiating reward claim from pool ${poolAddress.slice(0, 6)}...${poolAddress.slice(-4)}...`);
            try {
                const pool = new web3.eth.Contract(poolAbi, poolAddress);
                const rewardTokens = await withRetry(() => pool.methods.rewardTokens().call());
                const validRewardTokens = rewardTokens.filter(validateAddress);
                if (validRewardTokens.length === 0) {
                    logStatus("No reward tokens available to claim.", 'error');
                    alert("No reward tokens available to claim.");
                    return;
                }
                const result = await claimRewards(poolAddress, validRewardTokens);
                if (result.error) {
                    logStatus(result.error, 'error');
                    alert(result.error);
                } else {
                    logStatus(result.success, 'success');
                    await refreshPools();
                }
            } catch (err) {
                console.error(`Claim rewards failed: ${err.message}`);
                logStatus(`Failed to claim rewards: ${err.message}`, 'error');
                alert(`Failed to claim rewards: ${err.message}`);
            } finally {
                hideSpinner(button, originalText);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                logStatus(`Copied address ${text.slice(0, 6)}...${text.slice(-4)} to clipboard`, 'success');
            }).catch(err => {
                console.error(`Failed to copy: ${err.message}`);
                logStatus(`Failed to copy address: ${err.message}`, 'error');
            });
        }

        function updateBreakevenFormula() {
            const hardLock = document.getElementById('breakeven-hard-lock').value;
            const initialPenalty = document.getElementById('breakeven-initial-penalty').value;
            const decay = document.getElementById('breakeven-decay').value;

            document.getElementById('breakeven-hard-lock').value = hardLock;
            document.getElementById('breakeven-initial-penalty').value = initialPenalty;
            document.getElementById('breakeven-decay').value = decay;

            let result = '0';
            try {
                const hardLockNum = validateInteger(hardLock, 0);
                const initialPenaltyNum = validateInteger(initialPenalty, 0, 100);
                const decayNum = validateDecimal(decay, 0, 100, 4);
                if (hardLockNum && initialPenaltyNum && decayNum) {
                    const breakevenDays = Number(hardLockNum) + (Number(initialPenaltyNum) / Number(decayNum));
                    result = breakevenDays.toFixed(2);
                }
            } catch (e) {
                console.error(`Breakeven calculation error: ${e.message}`);
            }
            document.getElementById('breakeven-result').textContent = result;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            loadStatusLog();
            await initializeWallets();
            await refreshPools();
            updateBreakevenFormula();

            const inputs = ['hard-lock-duration', 'initial-penalty-percent', 'penalty-decay-percent'];
            inputs.forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    document.getElementById(`breakeven-${id}`).value = document.getElementById(id).value;
                    updateBreakevenFormula();
                });
            });
        });
    </script>
</body>
</html>
